---
alwaysApply: false
description: Global state management via context or React Query
---

# √âtat global

**Objectif** : D√©finir les bonnes pratiques pour la gestion d'√©tat global avec Context API et React Query.

**Contexte** : √Ä appliquer pour garantir la coh√©rence de la gestion de l'√©tat et des donn√©es.

## Explication

L'√©tat global est un √©tat partag√© entre plusieurs composants √† diff√©rents niveaux de l'arbre. Il existe plusieurs solutions selon le type d'√©tat.

**Quand utiliser Context :**

- √âtat UI global (th√®me, langue, sidebar ouvert/ferm√©)
- Configuration globale
- √âtat d'authentification
- Pas de donn√©es serveur

**Quand utiliser React Query :**

- Donn√©es serveur (voir `state/server.mdc`)
- Cache partag√©
- Synchronisation automatique

**√âviter :**

- Context pour toutes les donn√©es (performance)
- State management externe (Redux) sauf cas tr√®s complexes

## Exemple de mise en pratique

**Context simple pour UI :**

```tsx
// src/contexts/theme-context.tsx
import { createContext, useContext, useState, ReactNode } from "react";

type Theme = "light" | "dark";

interface ThemeContextValue {
  theme: Theme;
  setTheme: (theme: Theme) => void;
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextValue | undefined>(undefined);

export function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState<Theme>("light");

  const toggleTheme = () => {
    setTheme((prev) => (prev === "light" ? "dark" : "light"));
  };

  return <ThemeContext.Provider value={{ theme, setTheme, toggleTheme }}>{children}</ThemeContext.Provider>;
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error("useTheme must be used within ThemeProvider");
  }
  return context;
}

// Usage
// app/layout.tsx
import { ThemeProvider } from "@/contexts/theme-context";

export default function RootLayout({ children }: { children: ReactNode }) {
  return (
    <html>
      <body>
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  );
}

// Composant quelconque
import { useTheme } from "@/contexts/theme-context";

export function ThemeToggle() {
  const { theme, toggleTheme } = useTheme();
  return <button onClick={toggleTheme}>{theme === "light" ? "üåô" : "‚òÄÔ∏è"}</button>;
}
```

**Context avec reducer (√©tat complexe) :**

```tsx
// src/contexts/sidebar-context.tsx
import { createContext, useContext, useReducer, ReactNode } from "react";

interface SidebarState {
  isOpen: boolean;
  isPinned: boolean;
  width: number;
}

type SidebarAction =
  | { type: "TOGGLE" }
  | { type: "OPEN" }
  | { type: "CLOSE" }
  | { type: "TOGGLE_PIN" }
  | { type: "SET_WIDTH"; payload: number };

const initialState: SidebarState = {
  isOpen: true,
  isPinned: false,
  width: 250,
};

function sidebarReducer(state: SidebarState, action: SidebarAction): SidebarState {
  switch (action.type) {
    case "TOGGLE":
      return { ...state, isOpen: !state.isOpen };
    case "OPEN":
      return { ...state, isOpen: true };
    case "CLOSE":
      return { ...state, isOpen: false };
    case "TOGGLE_PIN":
      return { ...state, isPinned: !state.isPinned };
    case "SET_WIDTH":
      return { ...state, width: action.payload };
    default:
      return state;
  }
}

interface SidebarContextValue {
  state: SidebarState;
  dispatch: React.Dispatch<SidebarAction>;
}

const SidebarContext = createContext<SidebarContextValue | undefined>(undefined);

export function SidebarProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(sidebarReducer, initialState);

  return <SidebarContext.Provider value={{ state, dispatch }}>{children}</SidebarContext.Provider>;
}

export function useSidebar() {
  const context = useContext(SidebarContext);
  if (!context) {
    throw new Error("useSidebar must be used within SidebarProvider");
  }
  return context;
}

// Hook avec actions pr√©d√©finies
export function useSidebarActions() {
  const { dispatch } = useSidebar();

  return {
    toggle: () => dispatch({ type: "TOGGLE" }),
    open: () => dispatch({ type: "OPEN" }),
    close: () => dispatch({ type: "CLOSE" }),
    togglePin: () => dispatch({ type: "TOGGLE_PIN" }),
    setWidth: (width: number) => dispatch({ type: "SET_WIDTH", payload: width }),
  };
}

// Usage
export function SidebarToggle() {
  const { toggle } = useSidebarActions();
  return <button onClick={toggle}>Toggle Sidebar</button>;
}
```

**Context avec localStorage :**

```tsx
// src/contexts/preferences-context.tsx
import { createContext, useContext, useState, useEffect, ReactNode } from "react";

interface Preferences {
  language: string;
  timezone: string;
  dateFormat: string;
}

const defaultPreferences: Preferences = {
  language: "en",
  timezone: "UTC",
  dateFormat: "MM/DD/YYYY",
};

interface PreferencesContextValue {
  preferences: Preferences;
  updatePreferences: (updates: Partial<Preferences>) => void;
  resetPreferences: () => void;
}

const PreferencesContext = createContext<PreferencesContextValue | undefined>(undefined);

export function PreferencesProvider({ children }: { children: ReactNode }) {
  const [preferences, setPreferences] = useState<Preferences>(() => {
    if (typeof window === "undefined") return defaultPreferences;
    const stored = localStorage.getItem("preferences");
    return stored ? JSON.parse(stored) : defaultPreferences;
  });

  useEffect(() => {
    localStorage.setItem("preferences", JSON.stringify(preferences));
  }, [preferences]);

  const updatePreferences = (updates: Partial<Preferences>) => {
    setPreferences((prev) => ({ ...prev, ...updates }));
  };

  const resetPreferences = () => {
    setPreferences(defaultPreferences);
  };

  return <PreferencesContext.Provider value={{ preferences, updatePreferences, resetPreferences }}>{children}</PreferencesContext.Provider>;
}

export function usePreferences() {
  const context = useContext(PreferencesContext);
  if (!context) {
    throw new Error("usePreferences must be used within PreferencesProvider");
  }
  return context;
}
```

**Optimisation : split des contexts :**

```tsx
// ‚ùå Mauvais : un seul context pour tout
interface AppContextValue {
  user: User | null;
  theme: Theme;
  sidebar: SidebarState;
  notifications: Notification[];
  // ... beaucoup d'√©tats
}

// Tous les composants se re-render quand n'importe quel √©tat change

// ‚úÖ Bon : contexts s√©par√©s
// src/contexts/auth-context.tsx
const AuthContext = createContext<AuthContextValue | undefined>(undefined);

// src/contexts/theme-context.tsx
const ThemeContext = createContext<ThemeContextValue | undefined>(undefined);

// src/contexts/sidebar-context.tsx
const SidebarContext = createContext<SidebarContextValue | undefined>(undefined);

// Chaque composant n'utilise que ce dont il a besoin
```

**Context avec m√©mo√Øsation :**

```tsx
// src/contexts/auth-context.tsx
import { createContext, useContext, useState, useMemo, ReactNode } from "react";

interface User {
  id: string;
  email: string;
  name: string;
}

interface AuthContextValue {
  user: User | null;
  isAuthenticated: boolean;
  login: (user: User) => void;
  logout: () => void;
}

const AuthContext = createContext<AuthContextValue | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);

  // ‚úÖ M√©mo√Øser la valeur du context pour √©viter les re-renders inutiles
  const value = useMemo(
    () => ({
      user,
      isAuthenticated: user !== null,
      login: (user: User) => setUser(user),
      logout: () => setUser(null),
    }),
    [user]
  );

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within AuthProvider");
  }
  return context;
}
```

**Composition de providers :**

```tsx
// src/providers/app-providers.tsx
import { ReactNode } from "react";
import { QueryClientProvider } from "@tanstack/react-query";
import { queryClient } from "@/lib/react-query";
import { ThemeProvider } from "@/contexts/theme-context";
import { AuthProvider } from "@/contexts/auth-context";
import { SidebarProvider } from "@/contexts/sidebar-context";

export function AppProviders({ children }: { children: ReactNode }) {
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider>
        <AuthProvider>
          <SidebarProvider>{children}</SidebarProvider>
        </AuthProvider>
      </ThemeProvider>
    </QueryClientProvider>
  );
}

// app/layout.tsx
export default function RootLayout({ children }: { children: ReactNode }) {
  return (
    <html>
      <body>
        <AppProviders>{children}</AppProviders>
      </body>
    </html>
  );
}
```

**Context selector pattern :**

```tsx
// src/contexts/app-context.tsx
import { createContext, useContext, useContextSelector } from "use-context-selector";

interface AppState {
  user: User | null;
  theme: Theme;
  sidebar: SidebarState;
}

const AppContext = createContext<AppState | undefined>(undefined);

// Hook qui n'√©coute qu'une partie du state
export function useUser() {
  return useContextSelector(AppContext, (state) => state?.user);
}

export function useTheme() {
  return useContextSelector(AppContext, (state) => state?.theme);
}

// Le composant ne se re-render que si user change
export function UserProfile() {
  const user = useUser(); // Ne re-render pas si theme ou sidebar change
  return <div>{user?.name}</div>;
}
```

## Variantes ou exceptions

- Les applications tr√®s complexes peuvent n√©cessiter Zustand ou Redux.
- Les donn√©es serveur doivent toujours utiliser React Query, pas Context.

## Liens / R√©f√©rences

- [React Context](https://react.dev/reference/react/createContext)
- [useContext Hook](https://react.dev/reference/react/useContext)
- Documentation interne : `references.md`
