---
alwaysApply: false
description: Derived state and computed values management
---

# Derived State

**Objective**: Define best practices for managing derived states and computed values.

**Context**: To be applied to ensure consistency in state and data management.

## Explanation

A derived state is a value calculated from other states or props. It should **never** be stored in state, but rather calculated on the fly or memoized with `useMemo`.

**Rules:**

- **No state duplication**: do not store a value that can be calculated.
- **useMemo for expensive calculations**: memoize heavy computations.
- **Simple variables for light calculations**: no need for `useMemo` for simple calculations.
- **Always derive from the source of truth**: never synchronize two states.

## Practical Implementation Example

**Simple derived state (without useMemo):**

```tsx
import { useState } from "react";

export function ShoppingCart() {
  const [items, setItems] = useState([
    { id: "1", name: "Product 1", price: 10, quantity: 2 },
    { id: "2", name: "Product 2", price: 20, quantity: 1 },
  ]);

  // ✅ Good: calculated on each render (lightweight)
  const itemCount = items.length;
  const totalQuantity = items.reduce((sum, item) => sum + item.quantity, 0);
  const subtotal = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
  const tax = subtotal * 0.1;
  const total = subtotal + tax;

  return (
    <div>
      <p>Items: {itemCount}</p>
      <p>Total Quantity: {totalQuantity}</p>
      <p>Subtotal: ${subtotal.toFixed(2)}</p>
      <p>Tax: ${tax.toFixed(2)}</p>
      <p>Total: ${total.toFixed(2)}</p>
    </div>
  );
}
```

**Derived state with useMemo (expensive calculation):**

```tsx
import { useState, useMemo } from "react";

interface Product {
  id: string;
  name: string;
  price: number;
  category: string;
}

export function ProductList() {
  const [products, setProducts] = useState<Product[]>([]);
  const [searchQuery, setSearchQuery] = useState("");
  const [sortBy, setSortBy] = useState<"name" | "price">("name");

  // ✅ Good: useMemo for filtering and sorting (expensive with many products)
  const filteredAndSortedProducts = useMemo(() => {
    let result = products;

    // Filtering
    if (searchQuery) {
      result = result.filter((p) => p.name.toLowerCase().includes(searchQuery.toLowerCase()));
    }

    // Sorting
    result = [...result].sort((a, b) => {
      if (sortBy === "name") {
        return a.name.localeCompare(b.name);
      }
      return a.price - b.price;
    });

    return result;
  }, [products, searchQuery, sortBy]);

  // ✅ Good: lightweight calculation without useMemo
  const productCount = filteredAndSortedProducts.length;

  return (
    <div>
      <input value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} placeholder="Search..." />
      <select value={sortBy} onChange={(e) => setSortBy(e.target.value as "name" | "price")}>
        <option value="name">Name</option>
        <option value="price">Price</option>
      </select>
      <p>Found {productCount} products</p>
      <ul>
        {filteredAndSortedProducts.map((product) => (
          <li key={product.id}>
            {product.name} - ${product.price}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

**Anti-pattern: state duplication:**

```tsx
import { useState, useEffect } from "react";

// ❌ Bad: state duplication
export function CounterBad() {
  const [count, setCount] = useState(0);
  const [doubleCount, setDoubleCount] = useState(0);

  useEffect(() => {
    setDoubleCount(count * 2);
  }, [count]);

  return <div>Double: {doubleCount}</div>;
}

// ✅ Good: derived state
export function CounterGood() {
  const [count, setCount] = useState(0);
  const doubleCount = count * 2; // Calculated directly

  return <div>Double: {doubleCount}</div>;
}
```

**Derived state with formatting:**

```tsx
import { useState, useMemo } from "react";

export function PriceDisplay() {
  const [price, setPrice] = useState(1234.56);
  const [currency, setCurrency] = useState<"USD" | "EUR">("USD");

  // ✅ Good: derived formatting with useMemo
  const formattedPrice = useMemo(() => {
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency,
    }).format(price);
  }, [price, currency]);

  return (
    <div>
      <p>Price: {formattedPrice}</p>
      <input type="number" value={price} onChange={(e) => setPrice(Number(e.target.value))} />
      <select value={currency} onChange={(e) => setCurrency(e.target.value as "USD" | "EUR")}>
        <option value="USD">USD</option>
        <option value="EUR">EUR</option>
      </select>
    </div>
  );
}
```

**Derived state from props:**

```tsx
import { useMemo } from "react";

interface User {
  firstName: string;
  lastName: string;
  email: string;
}

interface UserCardProps {
  user: User;
}

export function UserCard({ user }: UserCardProps) {
  // ✅ Good: derive from props
  const fullName = `${user.firstName} ${user.lastName}`;
  const initials = `${user.firstName[0]}${user.lastName[0]}`.toUpperCase();
  const emailDomain = user.email.split("@")[1];

  return (
    <div>
      <div>{initials}</div>
      <h2>{fullName}</h2>
      <p>{user.email}</p>
      <span>@{emailDomain}</span>
    </div>
  );
}
```

**Derived state with grouping:**

```tsx
import { useMemo } from "react";

interface Transaction {
  id: string;
  date: Date;
  amount: number;
  category: string;
}

interface TransactionListProps {
  transactions: Transaction[];
}

export function TransactionList({ transactions }: TransactionListProps) {
  // ✅ Good: grouping by category with useMemo
  const groupedByCategory = useMemo(() => {
    return transactions.reduce(
      (acc, transaction) => {
        if (!acc[transaction.category]) {
          acc[transaction.category] = [];
        }
        acc[transaction.category].push(transaction);
        return acc;
      },
      {} as Record<string, Transaction[]>
    );
  }, [transactions]);

  // ✅ Good: derived statistics
  const totalByCategory = useMemo(() => {
    return Object.entries(groupedByCategory).map(([category, items]) => ({
      category,
      total: items.reduce((sum, item) => sum + item.amount, 0),
      count: items.length,
    }));
  }, [groupedByCategory]);

  return (
    <div>
      {totalByCategory.map(({ category, total, count }) => (
        <div key={category}>
          <h3>{category}</h3>
          <p>
            {count} transactions - ${total.toFixed(2)}
          </p>
        </div>
      ))}
    </div>
  );
}
```

**When to use useMemo:**

```tsx
import { useState, useMemo } from "react";

export function Example() {
  const [items, setItems] = useState([1, 2, 3, 4, 5]);

  // ❌ No need for useMemo: very simple calculation
  const length = useMemo(() => items.length, [items]);

  // ❌ No need for useMemo: lightweight operation
  const doubled = useMemo(() => items.map((n) => n * 2), [items]);

  // ✅ useMemo useful: expensive recursive calculation
  const fibonacci = useMemo(() => {
    function fib(n: number): number {
      if (n <= 1) return n;
      return fib(n - 1) + fib(n - 2);
    }
    return items.map(fib);
  }, [items]);

  // ✅ useMemo useful: filtering and sorting large list
  const sortedItems = useMemo(() => {
    return [...items].sort((a, b) => b - a);
  }, [items]);
}
```

**Derived state with validation:**

```tsx
import { useState, useMemo } from "react";

export function PasswordInput() {
  const [password, setPassword] = useState("");

  // ✅ Good: derived validation
  const validation = useMemo(() => {
    return {
      hasMinLength: password.length >= 8,
      hasUpperCase: /[A-Z]/.test(password),
      hasLowerCase: /[a-z]/.test(password),
      hasNumber: /\d/.test(password),
      hasSpecialChar: /[!@#$%^&*]/.test(password),
    };
  }, [password]);

  const isValid = Object.values(validation).every(Boolean);

  return (
    <div>
      <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} />
      <ul>
        <li className={validation.hasMinLength ? "text-green-500" : "text-red-500"}>At least 8 characters</li>
        <li className={validation.hasUpperCase ? "text-green-500" : "text-red-500"}>One uppercase letter</li>
        <li className={validation.hasLowerCase ? "text-green-500" : "text-red-500"}>One lowercase letter</li>
        <li className={validation.hasNumber ? "text-green-500" : "text-red-500"}>One number</li>
        <li className={validation.hasSpecialChar ? "text-green-500" : "text-red-500"}>One special character</li>
      </ul>
      <button disabled={!isValid}>Submit</button>
    </div>
  );
}
```

## Variants or Exceptions

- Really expensive calculations (> 50ms) should be moved to a Web Worker.
- Derived data that requires API calls should use React Query.

## Links / References

- [useMemo Hook](https://react.dev/reference/react/useMemo)
- [Avoiding Re-renders](https://react.dev/learn/render-and-commit)
- Internal documentation: `references.md`
