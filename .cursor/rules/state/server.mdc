---
alwaysApply: false
description: Server state and cache management with React Query
---

# Server State

**Objective**: Define best practices for cache and server state management with React Query.

**Context**: To be applied to ensure consistency in state and data management.

## Explanation

Server state is state that lives on the server and is synchronized with the client. React Query is the reference tool for managing this state.

**Key Principles:**

- **React Query for all server data**: no useState for API data.
- **Consistent query keys**: use strict naming conventions.
- **Automatic invalidation**: after mutations.
- **Centralized configuration**: in `lib/react-query.ts`.
- **No duplication**: React Query is the source of truth.

## Practical Implementation Example

**Configuration React Query :**

```ts
// src/lib/react-query.ts
import { QueryClient } from "@tanstack/react-query";

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      gcTime: 10 * 60 * 1000, // 10 minutes (anciennement cacheTime)
      refetchOnWindowFocus: false,
      retry: 1,
    },
  },
});
```

**Query simple :**

```ts
// src/features/users/hooks/use-users.ts
import { useQuery } from "@tanstack/react-query";
import { fetchUsers } from "../services";

export function useUsers() {
  return useQuery({
    queryKey: ["users"],
    queryFn: fetchUsers,
  });
}

// Usage
import { useUsers } from "@/features/users/hooks";

export function UserList() {
  const { data: users, isLoading, error } = useUsers();

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <ul>
      {users?.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

**Query avec paramètres :**

```ts
// src/features/users/hooks/use-user.ts
import { useQuery } from "@tanstack/react-query";
import { fetchUserById } from "../services";

export function useUser(userId: string) {
  return useQuery({
    queryKey: ["users", userId],
    queryFn: () => fetchUserById(userId),
    enabled: !!userId, // Ne fetch que si userId existe
  });
}

// Usage
export function UserProfile({ userId }: { userId: string }) {
  const { data: user, isLoading } = useUser(userId);

  if (isLoading) return <div>Loading...</div>;

  return <div>{user?.name}</div>;
}
```

**Query keys structurées :**

```ts
// src/features/users/queries.ts
export const userKeys = {
  all: ["users"] as const,
  lists: () => [...userKeys.all, "list"] as const,
  list: (filters: string) => [...userKeys.lists(), { filters }] as const,
  details: () => [...userKeys.all, "detail"] as const,
  detail: (id: string) => [...userKeys.details(), id] as const,
};

// Usage
import { userKeys } from "../queries";

export function useUser(id: string) {
  return useQuery({
    queryKey: userKeys.detail(id),
    queryFn: () => fetchUserById(id),
  });
}

export function useUsers(filters?: string) {
  return useQuery({
    queryKey: userKeys.list(filters || ""),
    queryFn: () => fetchUsers({ filters }),
  });
}
```

**Mutation avec invalidation :**

```ts
// src/features/users/hooks/use-create-user.ts
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { createUser } from "../services";
import { userKeys } from "../queries";
import type { CreateUserInput } from "../types";

export function useCreateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreateUserInput) => createUser(data),
    onSuccess: () => {
      // Invalider toutes les queries de users
      queryClient.invalidateQueries({ queryKey: userKeys.all });
    },
  });
}

// Usage
export function CreateUserForm() {
  const createMutation = useCreateUser();

  const handleSubmit = async (data: CreateUserInput) => {
    try {
      await createMutation.mutateAsync(data);
      toast.success("User created");
    } catch (error) {
      toast.error("Failed to create user");
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Form fields */}
      <button type="submit" disabled={createMutation.isPending}>
        {createMutation.isPending ? "Creating..." : "Create User"}
      </button>
    </form>
  );
}
```

**Mutation avec mise à jour optimiste :**

```ts
// src/features/todos/hooks/use-toggle-todo.ts
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { toggleTodo } from "../services";
import { todoKeys } from "../queries";
import type { Todo } from "../types";

export function useToggleTodo() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (todoId: string) => toggleTodo(todoId),
    onMutate: async (todoId) => {
      // Annuler les requêtes en cours
      await queryClient.cancelQueries({ queryKey: todoKeys.all });

      // Snapshot de la valeur actuelle
      const previousTodos = queryClient.getQueryData<Todo[]>(todoKeys.all);

      // Mise à jour optimiste
      queryClient.setQueryData<Todo[]>(todoKeys.all, (old) => {
        if (!old) return [];
        return old.map((todo) => (todo.id === todoId ? { ...todo, completed: !todo.completed } : todo));
      });

      // Retourner le contexte pour rollback
      return { previousTodos };
    },
    onError: (err, todoId, context) => {
      // Rollback en cas d'erreur
      if (context?.previousTodos) {
        queryClient.setQueryData(todoKeys.all, context.previousTodos);
      }
    },
    onSettled: () => {
      // Refetch après succès ou erreur
      queryClient.invalidateQueries({ queryKey: todoKeys.all });
    },
  });
}
```

**Query avec pagination :**

```ts
// src/features/products/hooks/use-products.ts
import { useQuery } from "@tanstack/react-query";
import { fetchProducts } from "../services";

interface UseProductsOptions {
  page?: number;
  limit?: number;
}

export function useProducts({ page = 1, limit = 20 }: UseProductsOptions = {}) {
  return useQuery({
    queryKey: ["products", { page, limit }],
    queryFn: () => fetchProducts({ page, limit }),
    placeholderData: (previousData) => previousData, // Garder les données précédentes pendant le chargement
  });
}

// Usage
export function ProductList() {
  const [page, setPage] = useState(1);
  const { data, isLoading, isPlaceholderData } = useProducts({ page });

  return (
    <div>
      <div className={isPlaceholderData ? "opacity-50" : ""}>
        {data?.products.map((product) => (
          <ProductCard key={product.id} product={product} />
        ))}
      </div>
      <button onClick={() => setPage((p) => p - 1)} disabled={page === 1}>
        Previous
      </button>
      <button onClick={() => setPage((p) => p + 1)} disabled={isPlaceholderData || !data?.hasMore}>
        Next
      </button>
    </div>
  );
}
```

**Infinite Query :**

```ts
// src/features/posts/hooks/use-infinite-posts.ts
import { useInfiniteQuery } from "@tanstack/react-query";
import { fetchPosts } from "../services";

export function useInfinitePosts() {
  return useInfiniteQuery({
    queryKey: ["posts", "infinite"],
    queryFn: ({ pageParam = 1 }) => fetchPosts({ page: pageParam }),
    getNextPageParam: (lastPage, allPages) => {
      return lastPage.hasMore ? allPages.length + 1 : undefined;
    },
    initialPageParam: 1,
  });
}

// Usage
export function InfinitePostList() {
  const { data, fetchNextPage, hasNextPage, isFetchingNextPage } = useInfinitePosts();

  return (
    <div>
      {data?.pages.map((page) =>
        page.posts.map((post) => <PostCard key={post.id} post={post} />)
      )}
      {hasNextPage && (
        <button onClick={() => fetchNextPage()} disabled={isFetchingNextPage}>
          {isFetchingNextPage ? "Loading..." : "Load More"}
        </button>
      )}
    </div>
  );
}
```

**Query dépendante :**

```ts
// src/features/users/hooks/use-user-posts.ts
import { useQuery } from "@tanstack/react-query";
import { fetchUserById, fetchUserPosts } from "../services";

export function useUserWithPosts(userId: string) {
  // Query 1 : récupérer l'utilisateur
  const userQuery = useQuery({
    queryKey: ["users", userId],
    queryFn: () => fetchUserById(userId),
    enabled: !!userId,
  });

  // Query 2 : récupérer les posts (dépend de userQuery)
  const postsQuery = useQuery({
    queryKey: ["users", userId, "posts"],
    queryFn: () => fetchUserPosts(userId),
    enabled: !!userQuery.data, // Ne fetch que si user est chargé
  });

  return {
    user: userQuery.data,
    posts: postsQuery.data,
    isLoading: userQuery.isLoading || postsQuery.isLoading,
  };
}
```

**Prefetch pour UX optimale :**

```tsx
// src/features/products/components/product-list.tsx
import { useQueryClient } from "@tanstack/react-query";
import { fetchProductById } from "../services";

export function ProductList({ products }: { products: Product[] }) {
  const queryClient = useQueryClient();

  const handleMouseEnter = (productId: string) => {
    // Prefetch au hover pour instant navigation
    queryClient.prefetchQuery({
      queryKey: ["products", productId],
      queryFn: () => fetchProductById(productId),
      staleTime: 5 * 60 * 1000,
    });
  };

  return (
    <div>
      {products.map((product) => (
        <Link
          key={product.id}
          href={`/products/${product.id}`}
          onMouseEnter={() => handleMouseEnter(product.id)}
        >
          {product.name}
        </Link>
      ))}
    </div>
  );
}
```

**Gestion du cache manuel :**

```ts
// src/features/users/hooks/use-update-user.ts
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { updateUser } from "../services";
import { userKeys } from "../queries";
import type { User } from "../types";

export function useUpdateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: Partial<User> }) => updateUser(id, data),
    onSuccess: (updatedUser) => {
      // Mettre à jour le cache directement
      queryClient.setQueryData(userKeys.detail(updatedUser.id), updatedUser);

      // Invalider la liste
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    },
  });
}
```

## Variants or Exceptions

- Real-time data (< 5s polling) can use SWR.
- Next.js Server Components don't use React Query (direct fetch).

## Links / References

- [TanStack Query Documentation](https://tanstack.com/query/latest)
- [Query Keys](https://tanstack.com/query/latest/docs/react/guides/query-keys)
- Internal documentation: `references.md`
