---
alwaysApply: false
description: Real-time synchronization with SWR
---

# Synchronisation temps r√©el

**Objectif** : Standardiser la synchronisation en temps r√©el des donn√©es avec SWR pour les cas d'usage n√©cessitant un polling fr√©quent.

**Contexte** : √Ä appliquer pour garantir la coh√©rence de la gestion de l'√©tat et des donn√©es.

## Explication

SWR est utilis√© pour les donn√©es **volatiles** et **temps r√©el** qui n√©cessitent un polling fr√©quent (< 30 secondes) ou une synchronisation rapide.

**Quand utiliser SWR :**

- Donn√©es en temps r√©el (statuts, notifications, pr√©sence)
- Polling fr√©quent (< 30 secondes)
- Donn√©es tr√®s volatiles
- Synchronisation entre onglets

**Quand utiliser React Query :**

- Donn√©es persistantes
- Caching avanc√©
- Mutations complexes
- Polling > 30 secondes

## Exemple de mise en pratique

**Configuration SWR globale :**

```ts
// src/lib/swr.ts
export async function fetcher<T>(url: string): Promise<T> {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error("Failed to fetch");
  }
  return response.json();
}

// app/layout.tsx
"use client";

import { SWRConfig } from "swr";
import { fetcher } from "@/lib/swr";

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <SWRConfig
          value={{
            fetcher,
            revalidateOnFocus: false,
            shouldRetryOnError: false,
            refreshInterval: 0, // D√©sactiv√© par d√©faut
          }}
        >
          {children}
        </SWRConfig>
      </body>
    </html>
  );
}
```

**Donn√©es temps r√©el avec polling :**

```ts
// src/features/notifications/hooks/use-notifications.ts
import useSWR from "swr";
import { fetchNotifications } from "../services";

export function useNotifications() {
  return useSWR("/api/notifications", fetchNotifications, {
    refreshInterval: 10000, // Polling toutes les 10 secondes
    revalidateOnFocus: true,
    dedupingInterval: 5000, // √âviter les requ√™tes en doublon
  });
}

// Usage
export function NotificationBell() {
  const { data: notifications, isLoading } = useNotifications();

  const unreadCount = notifications?.filter((n) => !n.read).length || 0;

  return (
    <button>
      üîî
      {unreadCount > 0 && <span className="badge">{unreadCount}</span>}
    </button>
  );
}
```

**Pr√©sence utilisateur en temps r√©el :**

```ts
// src/features/presence/hooks/use-online-users.ts
import useSWR from "swr";
import { fetchOnlineUsers } from "../services";

export function useOnlineUsers() {
  return useSWR("/api/users/online", fetchOnlineUsers, {
    refreshInterval: 5000, // Tr√®s fr√©quent pour la pr√©sence
    revalidateOnReconnect: true,
  });
}

// Usage
export function OnlineUsersList() {
  const { data: onlineUsers } = useOnlineUsers();

  return (
    <div>
      <h3>{onlineUsers?.length || 0} users online</h3>
      <ul>
        {onlineUsers?.map((user) => (
          <li key={user.id}>
            <span className="online-indicator" />
            {user.name}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

**Mutation avec revalidation :**

```ts
// src/features/notifications/hooks/use-mark-as-read.ts
import useSWR, { useSWRConfig } from "swr";
import { markNotificationAsRead } from "../services";

export function useMarkAsRead() {
  const { mutate } = useSWRConfig();

  const markAsRead = async (notificationId: string) => {
    // Mise √† jour optimiste
    mutate(
      "/api/notifications",
      async (current: Notification[]) => {
        return current?.map((n) => (n.id === notificationId ? { ...n, read: true } : n));
      },
      { revalidate: false }
    );

    try {
      // Appel API
      await markNotificationAsRead(notificationId);

      // Revalidation apr√®s succ√®s
      mutate("/api/notifications");
    } catch (error) {
      // Rollback en cas d'erreur
      mutate("/api/notifications");
      throw error;
    }
  };

  return { markAsRead };
}

// Usage
export function NotificationItem({ notification }: { notification: Notification }) {
  const { markAsRead } = useMarkAsRead();

  const handleClick = async () => {
    await markAsRead(notification.id);
  };

  return (
    <div onClick={handleClick} className={notification.read ? "opacity-50" : ""}>
      {notification.message}
    </div>
  );
}
```

**Donn√©es conditionnelles :**

```ts
// src/features/chat/hooks/use-messages.ts
import useSWR from "swr";
import { fetchMessages } from "../services";

export function useMessages(chatId: string | null) {
  return useSWR(
    chatId ? `/api/chats/${chatId}/messages` : null, // Ne fetch que si chatId existe
    () => fetchMessages(chatId!),
    {
      refreshInterval: 3000, // Polling rapide pour chat
    }
  );
}

// Usage
export function ChatWindow({ chatId }: { chatId: string | null }) {
  const { data: messages, isLoading } = useMessages(chatId);

  if (!chatId) return <div>Select a chat</div>;
  if (isLoading) return <div>Loading messages...</div>;

  return (
    <div>
      {messages?.map((msg) => (
        <div key={msg.id}>{msg.content}</div>
      ))}
    </div>
  );
}
```

**Synchronisation entre onglets :**

```ts
// src/hooks/use-cart.ts
import useSWR from "swr";
import { fetchCart } from "../services";

export function useCart() {
  return useSWR("/api/cart", fetchCart, {
    refreshInterval: 0, // Pas de polling
    revalidateOnFocus: true, // Revalider au focus
    revalidateOnReconnect: true, // Revalider √† la reconnexion
    dedupingInterval: 2000,
  });
}

// Le panier se synchronise automatiquement entre les onglets
```

**Statut de connexion :**

```ts
// src/hooks/use-connection-status.ts
import useSWR from "swr";

export function useConnectionStatus() {
  return useSWR(
    "/api/health",
    async () => {
      const response = await fetch("/api/health");
      return response.ok;
    },
    {
      refreshInterval: 10000,
      onError: () => {
        // G√©rer la perte de connexion
        console.warn("Connection lost");
      },
      onSuccess: (isConnected) => {
        if (isConnected) {
          console.log("Connection restored");
        }
      },
    }
  );
}

// Usage
export function ConnectionIndicator() {
  const { data: isConnected, isLoading } = useConnectionStatus();

  if (isLoading) return null;

  return (
    <div className={isConnected ? "text-green-500" : "text-red-500"}>
      {isConnected ? "üü¢ Connected" : "üî¥ Disconnected"}
    </div>
  );
}
```

**Donn√©es avec fallback :**

```ts
// src/features/dashboard/hooks/use-stats.ts
import useSWR from "swr";
import { fetchStats } from "../services";

const fallbackData = {
  users: 0,
  revenue: 0,
  orders: 0,
};

export function useStats() {
  return useSWR("/api/stats", fetchStats, {
    refreshInterval: 30000, // 30 secondes
    fallbackData, // Donn√©es par d√©faut en cas d'erreur
  });
}

// Les stats s'affichent toujours, m√™me en cas d'erreur
```

**Revalidation manuelle :**

```ts
// src/features/products/hooks/use-product-stock.ts
import useSWR from "swr";
import { fetchProductStock } from "../services";

export function useProductStock(productId: string) {
  const { data, mutate } = useSWR(`/api/products/${productId}/stock`, () => fetchProductStock(productId), {
    refreshInterval: 15000, // 15 secondes
  });

  const refreshStock = () => {
    mutate(); // Force revalidation
  };

  return {
    stock: data?.stock || 0,
    isLowStock: (data?.stock || 0) < 10,
    refreshStock,
  };
}

// Usage
export function ProductStock({ productId }: { productId: string }) {
  const { stock, isLowStock, refreshStock } = useProductStock(productId);

  return (
    <div>
      <span className={isLowStock ? "text-red-500" : ""}>{stock} in stock</span>
      <button onClick={refreshStock}>Refresh</button>
    </div>
  );
}
```

**Combine SWR + React Query :**

```tsx
// src/features/dashboard/components/dashboard.tsx
import { useNotifications } from "@/features/notifications/hooks"; // SWR
import { useUsers } from "@/features/users/hooks"; // React Query

export function Dashboard() {
  // SWR pour donn√©es temps r√©el
  const { data: notifications } = useNotifications();

  // React Query pour donn√©es persistantes
  const { data: users } = useUsers();

  return (
    <div>
      <NotificationBell notifications={notifications} />
      <UserList users={users} />
    </div>
  );
}
```

## Variantes ou exceptions

- Les donn√©es persistantes avec caching avanc√© doivent utiliser React Query.
- Les WebSockets sont pr√©f√©rables pour le temps r√©el < 1 seconde.

## Liens / R√©f√©rences

- [SWR Documentation](https://swr.vercel.app/)
- [SWR vs React Query](https://swr.vercel.app/docs/comparison)
- Documentation interne : `references.md`
