---
id: utils/functions
category: utils
title: Conventions de nommage et typage des utilitaires
status: draft
tags: [utils, functions, naming, typing, conventions]
---

# Utility Naming and Typing Conventions

**Objective**: Establish naming and typing conventions to ensure consistent, testable, and maintainable utility functions.
**Context**: To be applied to standardize shared helpers and functions.

## Explanation

Utility functions must follow strict conventions to facilitate their discovery, understanding, and reusability. Good naming and rigorous typing are essential.

**Naming principles:**

* **Action verbs**: `format`, `calculate`, `parse`, `transform`, `validate`, `generate`
* **Explicit names**: clearly describe what the function does
* **Consistent prefixes**: `is` (boolean), `get` (retrieval), `format` (formatting)
* **camelCase**: standard JavaScript convention
* **No abbreviations**: `formatCurrency` rather than `fmtCur`

**Typing conventions:**

* **Explicit types**: type parameters and returns
* **Never `any`**: use `unknown` if necessary
* **Generic types**: for reusable functions
* **Discriminated unions**: for complex options
* **Optional return types**: `| null` or `| undefined` if relevant

**Structure of a utility function:**

1. JSDoc with description, params, and return
2. Typed function signature
3. Input validation if necessary
4. Business logic
5. Return result

**File organization:**

* 1 function = 1 file
* File name = function name in kebab-case
* Grouping by domain (strings, dates, numbers)
* Barrel (`index.ts`) for exports

**Best practices:**

* Pure functions (no side effects)
* Unit testable
* Complete JSDoc documentation
* Explicit handling of edge cases
* Optimized performance (avoid unnecessary loops)

**Mistakes to avoid:**

* Vague names (`processData`, `handleStuff`)
* Loose typing (`any`, untyped parameters)
* Functions too long (> 30 lines)
* Mixed responsibilities
* Lack of documentation

## Practical Implementation Example

```ts
// src/utils/strings/slugify.ts

/**
 * Converts a string to a URL-friendly slug
 *
 * @param text - Text to convert to slug
 * @returns Lowercase slug with hyphens, without special characters
 *
 * @example
 * ```ts
 * slugify('Hello World!') // => 'hello-world'
 * slugify('Café Français') // => 'cafe-francais'
 * ```
 */
export function slugify(text: string): string {
  return text
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

// src/utils/numbers/format-currency.ts

type CurrencyOptions = {
  locale?: string;
  currency?: string;
};

/**
 * Formats an amount in currency
 *
 * @param amount - Amount in cents
 * @param options - Formatting options
 * @returns Formatted amount with currency symbol
 *
 * @example
 * ```ts
 * formatCurrency(1999) // => '19,99 €'
 * formatCurrency(1999, { currency: 'USD' }) // => '$19.99'
 * ```
 */
export function formatCurrency(
  amount: number,
  options: CurrencyOptions = {}
): string {
  const { locale = 'fr-FR', currency = 'EUR' } = options;

  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency,
  }).format(amount / 100);
}

// src/utils/arrays/group-by.ts

/**
 * Regroupe les éléments d'un tableau selon une clé
 *
 * @param array - Tableau à regrouper
 * @param keyFn - Fonction retournant la clé de regroupement
 * @returns Objet avec les éléments regroupés par clé
 *
 * @example
 * ```ts
 * const users = [
 *   { id: 1, role: 'admin' },
 *   { id: 2, role: 'user' },
 *   { id: 3, role: 'admin' },
 * ];
 * groupBy(users, (u) => u.role)
 * // => { admin: [{...}, {...}], user: [{...}] }
 * ```
 */
export function groupBy<T, K extends string | number>(
  array: T[],
  keyFn: (item: T) => K
): Record<K, T[]> {
  return array.reduce(
    (acc, item) => {
      const key = keyFn(item);
      if (!acc[key]) {
        acc[key] = [];
      }
      acc[key].push(item);
      return acc;
    },
    {} as Record<K, T[]>
  );
}

// src/utils/validators/is-email.ts

/**
 * Vérifie si une chaîne est un email valide
 *
 * @param value - Valeur à vérifier
 * @returns `true` si l'email est valide, `false` sinon
 *
 * @example
 * ```ts
 * isEmail('user@example.com') // => true
 * isEmail('invalid') // => false
 * ```
 */
export function isEmail(value: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(value);
}

// src/utils/dates/format-date.ts

type DateFormatOptions = {
  locale?: string;
  format?: 'short' | 'long' | 'numeric';
};

/**
 * Formate une date selon les options spécifiées
 *
 * @param date - Date à formater
 * @param options - Options de formatage
 * @returns Date formatée en français par défaut
 *
 * @example
 * ```ts
 * formatDate(new Date('2025-10-27')) // => '27 octobre 2025'
 * formatDate(new Date('2025-10-27'), { format: 'short' }) // => '27/10/2025'
 * ```
 */
export function formatDate(
  date: Date,
  options: DateFormatOptions = {}
): string {
  const { locale = 'fr-FR', format = 'long' } = options;

  const formatOptions: Intl.DateTimeFormatOptions =
    format === 'short'
      ? { day: '2-digit', month: '2-digit', year: 'numeric' }
      : format === 'numeric'
      ? { dateStyle: 'short' }
      : { day: 'numeric', month: 'long', year: 'numeric' };

  return new Intl.DateTimeFormat(locale, formatOptions).format(date);
}

// src/utils/index.ts (barrel)
export * from './strings';
export * from './numbers';
export * from './arrays';
export * from './dates';
export * from './validators';
```

## Variantes ou exceptions

* Les helpers très spécifiques à une feature peuvent avoir des conventions adaptées
* Les fonctions legacy peuvent ne pas suivre ces conventions (migration progressive)
* Les wrappers de librairies tierces peuvent garder les noms originaux

## Liens / Références

* https://github.com/basarat/typescript-book/blob/master/docs/styleguide/styleguide.md
* https://google.github.io/styleguide/tsguide.html
* Documentation interne : `/docs/code-conventions.md`
