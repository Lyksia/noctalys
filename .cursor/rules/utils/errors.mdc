---
id: utils/errors
category: utils
title: Helpers de gestion d'erreurs
status: draft
tags: [utils, errors, exceptions, error-handling]
---

# Helpers de gestion d'erreurs

**Objectif** : Standardiser la gestion des erreurs pour garantir cohérence et traçabilité.
**Contexte** : À appliquer pour standardiser les helpers et fonctions partagées.

## Explication

Une gestion d'erreurs cohérente facilite le debugging et améliore l'expérience utilisateur. Les helpers d'erreurs permettent de créer, typer et transformer les erreurs de manière standardisée.

**Principes :**

* Créer des classes d'erreur personnalisées
* Typer les erreurs avec TypeScript
* Logger les erreurs de manière structurée
* Fournir des messages d'erreur clairs pour l'utilisateur
* Séparer les erreurs techniques des erreurs métier

**Types d'erreurs :**

* **ValidationError** : erreurs de validation de données
* **ApiError** : erreurs d'API HTTP
* **AuthError** : erreurs d'authentification
* **NotFoundError** : ressource non trouvée
* **PermissionError** : accès refusé

## Exemple de mise en pratique

```ts
// src/utils/errors/base-error.ts

/**
 * Classe de base pour les erreurs personnalisées
 */
export class BaseError extends Error {
  public readonly code: string;
  public readonly statusCode: number;
  public readonly isOperational: boolean;

  constructor(
    message: string,
    code: string,
    statusCode: number = 500,
    isOperational: boolean = true
  ) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;
    this.statusCode = statusCode;
    this.isOperational = isOperational;

    Error.captureStackTrace(this, this.constructor);
  }
}

// src/utils/errors/validation-error.ts

/**
 * Erreur de validation de données
 */
export class ValidationError extends BaseError {
  public readonly fields: Record<string, string[]>;

  constructor(message: string, fields: Record<string, string[]> = {}) {
    super(message, 'VALIDATION_ERROR', 400);
    this.fields = fields;
  }
}

// src/utils/errors/api-error.ts

/**
 * Erreur d'API HTTP
 */
export class ApiError extends BaseError {
  public readonly endpoint: string;
  public readonly method: string;

  constructor(message: string, statusCode: number, endpoint: string, method: string) {
    super(message, 'API_ERROR', statusCode);
    this.endpoint = endpoint;
    this.method = method;
  }
}

// src/utils/errors/auth-error.ts

/**
 * Erreur d'authentification
 */
export class AuthError extends BaseError {
  constructor(message: string = 'Non autorisé') {
    super(message, 'AUTH_ERROR', 401);
  }
}

// src/utils/errors/not-found-error.ts

/**
 * Erreur de ressource non trouvée
 */
export class NotFoundError extends BaseError {
  public readonly resource: string;

  constructor(resource: string) {
    super(`${resource} non trouvé`, 'NOT_FOUND', 404);
    this.resource = resource;
  }
}

// src/utils/errors/handle-error.ts

/**
 * Gère les erreurs de manière centralisée
 * @param error - Erreur à gérer
 * @returns Message d'erreur pour l'utilisateur
 */
export function handleError(error: unknown): string {
  if (error instanceof ValidationError) {
    return `Validation échouée: ${error.message}`;
  }

  if (error instanceof ApiError) {
    return `Erreur API (${error.statusCode}): ${error.message}`;
  }

  if (error instanceof AuthError) {
    return 'Vous devez être connecté pour accéder à cette ressource.';
  }

  if (error instanceof NotFoundError) {
    return `${error.resource} introuvable.`;
  }

  if (error instanceof Error) {
    return error.message;
  }

  return 'Une erreur inattendue est survenue.';
}

// src/utils/errors/is-error-type.ts

/**
 * Vérifie si une erreur est d'un type donné
 * @param error - Erreur à vérifier
 * @param ErrorClass - Classe d'erreur
 * @returns true si l'erreur est du type donné
 */
export function isErrorType<T extends Error>(
  error: unknown,
  ErrorClass: new (...args: any[]) => T
): error is T {
  return error instanceof ErrorClass;
}

// src/utils/errors/format-error.ts

type FormattedError = {
  message: string;
  code?: string;
  statusCode?: number;
  stack?: string;
};

/**
 * Formate une erreur pour le logging ou l'API
 * @param error - Erreur à formater
 * @param includeStack - Inclure la stack trace
 * @returns Erreur formatée
 */
export function formatError(error: unknown, includeStack: boolean = false): FormattedError {
  if (error instanceof BaseError) {
    return {
      message: error.message,
      code: error.code,
      statusCode: error.statusCode,
      ...(includeStack && { stack: error.stack }),
    };
  }

  if (error instanceof Error) {
    return {
      message: error.message,
      ...(includeStack && { stack: error.stack }),
    };
  }

  return {
    message: String(error),
  };
}

// src/utils/errors/index.ts
export { BaseError } from './base-error';
export { ValidationError } from './validation-error';
export { ApiError } from './api-error';
export { AuthError } from './auth-error';
export { NotFoundError } from './not-found-error';
export { handleError } from './handle-error';
export { isErrorType } from './is-error-type';
export { formatError } from './format-error';

// Usage dans le code
import { ValidationError, NotFoundError, handleError } from '@/utils/errors';

// Lancer une erreur
if (!user) {
  throw new NotFoundError('Utilisateur');
}

// Gérer une erreur
try {
  await createUser(data);
} catch (error) {
  const message = handleError(error);
  toast.error(message);
}
```

## Variantes ou exceptions

* Les erreurs métier spécifiques peuvent être dans `features/[feature]/errors/`
* Pour des systèmes complexes, utiliser des librairies comme `ts-error`
* Les erreurs côté serveur (API Routes) nécessitent un logging différent

## Liens / Références

* https://nodejs.org/api/errors.html
* https://kentcdodds.com/blog/get-a-catch-block-error-message-with-typescript
* Documentation interne : `/docs/error-handling.md`
