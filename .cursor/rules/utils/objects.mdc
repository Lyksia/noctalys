---
id: utils/objects
category: utils
title: Helpers pour objets
status: draft
tags: [utils, objects, manipulation, typescript]
---

# Helpers pour objets

**Objectif** : Standardiser la manipulation d'objets pour garantir sécurité et réutilisabilité.
**Contexte** : À appliquer pour standardiser les helpers et fonctions partagées.

## Explication

Les helpers de manipulation d'objets facilitent les opérations courantes (merge, pick, omit) tout en préservant le typage TypeScript.

**Fonctions courantes :**

* **pick** : extraire certaines propriétés
* **omit** : exclure certaines propriétés
* **deepMerge** : fusionner des objets en profondeur
* **isEmpty** : vérifier si un objet est vide
* **deepClone** : cloner en profondeur
* **getNestedValue** : accéder à une valeur imbriquée

## Exemple de mise en pratique

```ts
// src/utils/objects/pick.ts

/**
 * Extrait certaines propriétés d'un objet
 * @param obj - Objet source
 * @param keys - Clés à extraire
 * @returns Nouvel objet avec les clés sélectionnées
 */
export function pick<T extends object, K extends keyof T>(
  obj: T,
  keys: K[]
): Pick<T, K> {
  const result = {} as Pick<T, K>;
  keys.forEach((key) => {
    if (key in obj) {
      result[key] = obj[key];
    }
  });
  return result;
}

// src/utils/objects/omit.ts

/**
 * Exclut certaines propriétés d'un objet
 * @param obj - Objet source
 * @param keys - Clés à exclure
 * @returns Nouvel objet sans les clés exclues
 */
export function omit<T extends object, K extends keyof T>(
  obj: T,
  keys: K[]
): Omit<T, K> {
  const result = { ...obj };
  keys.forEach((key) => {
    delete result[key];
  });
  return result;
}

// src/utils/objects/deep-merge.ts

/**
 * Fusionne des objets en profondeur
 * @param target - Objet cible
 * @param source - Objet source
 * @returns Objet fusionné
 */
export function deepMerge<T extends object>(target: T, source: Partial<T>): T {
  const result = { ...target };

  Object.keys(source).forEach((key) => {
    const sourceValue = source[key as keyof T];
    const targetValue = result[key as keyof T];

    if (
      sourceValue &&
      typeof sourceValue === 'object' &&
      !Array.isArray(sourceValue) &&
      targetValue &&
      typeof targetValue === 'object'
    ) {
      result[key as keyof T] = deepMerge(targetValue, sourceValue as any);
    } else {
      result[key as keyof T] = sourceValue as any;
    }
  });

  return result;
}

// src/utils/objects/is-empty.ts

/**
 * Vérifie si un objet est vide
 * @param obj - Objet à vérifier
 * @returns true si l'objet est vide
 */
export function isEmpty(obj: object): boolean {
  return Object.keys(obj).length === 0;
}

// src/utils/objects/deep-clone.ts

/**
 * Clone un objet en profondeur
 * @param obj - Objet à cloner
 * @returns Clone de l'objet
 */
export function deepClone<T>(obj: T): T {
  return JSON.parse(JSON.stringify(obj));
}

// src/utils/objects/get-nested-value.ts

/**
 * Récupère une valeur imbriquée dans un objet
 * @param obj - Objet source
 * @param path - Chemin vers la valeur (ex: 'user.address.city')
 * @returns Valeur trouvée ou undefined
 */
export function getNestedValue(obj: any, path: string): any {
  return path.split('.').reduce((current, key) => current?.[key], obj);
}

// src/utils/objects/index.ts
export { pick } from './pick';
export { omit } from './omit';
export { deepMerge } from './deep-merge';
export { isEmpty } from './is-empty';
export { deepClone } from './deep-clone';
export { getNestedValue } from './get-nested-value';
```

## Variantes ou exceptions

* Pour des manipulations complexes, utiliser `lodash` ou `ramda`
* `structuredClone` (natif) peut remplacer `deepClone`
* Les objets avec des méthodes nécessitent un clonage spécifique

## Liens / Références

* https://developer.mozilla.org/en-US/docs/Web/API/structuredClone
* https://lodash.com/docs
* Documentation interne : `/docs/utils.md`
