---
id: utils/tests
category: utils
title: Helpers pour tests (optionnel)
status: draft
tags: [utils, tests, testing, helpers, mocks]
---

# Helpers pour tests (optionnel)

**Objectif** : Créer des helpers de test réutilisables pour simplifier et standardiser les tests.
**Contexte** : À appliquer pour standardiser les helpers et fonctions partagées.

## Explication

Les helpers de test facilitent l'écriture de tests en fournissant des utilitaires réutilisables pour les cas courants (génération de données, assertions personnalisées, wrappers).

**Helpers courants :**

* **Factories** : générateurs de données de test
* **Wrappers** : providers pour React Query, Router, etc.
* **Assertions** : matchers personnalisés
* **Mocks** : fonctions mockées réutilisables
* **Utilities** : helpers pour les tests asynchrones, délais, etc.

**Organisation :**

```
test/
 └─ utils/
     ├─ factories/
     │   ├─ user.factory.ts
     │   └─ event.factory.ts
     ├─ mocks/
     │   ├─ user.mock.ts
     │   └─ handlers.ts
     ├─ render-with-providers.tsx
     ├─ wait-for-loading.ts
     └─ index.ts
```

## Exemple de mise en pratique

```ts
// test/utils/factories/user.factory.ts
import type { User } from '@/features/user/types';

let userIdCounter = 1;

/**
 * Factory pour créer des utilisateurs de test
 */
export function createUser(overrides?: Partial<User>): User {
  return {
    id: `user-${userIdCounter++}`,
    name: 'John Doe',
    email: `john${userIdCounter}@example.com`,
    avatar: null,
    createdAt: new Date(),
    ...overrides,
  };
}

/**
 * Factory pour créer plusieurs utilisateurs
 */
export function createUsers(count: number, overrides?: Partial<User>): User[] {
  return Array.from({ length: count }, (_, i) =>
    createUser({ name: `User ${i + 1}`, ...overrides })
  );
}

// test/utils/render-with-providers.tsx
import { ReactElement } from 'react';
import { render, RenderOptions } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

/**
 * Render avec tous les providers nécessaires
 */
export function renderWithProviders(
  ui: ReactElement,
  options?: RenderOptions & { queryClient?: QueryClient }
) {
  const queryClient =
    options?.queryClient ||
    new QueryClient({
      defaultOptions: {
        queries: { retry: false },
        mutations: { retry: false },
      },
    });

  function Wrapper({ children }: { children: React.ReactNode }) {
    return (
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    );
  }

  return {
    ...render(ui, { wrapper: Wrapper, ...options }),
    queryClient,
  };
}

// test/utils/wait-for-loading.ts
import { screen, waitForElementToBeRemoved } from '@testing-library/react';

/**
 * Attend la disparition du loader
 */
export async function waitForLoadingToFinish() {
  const loader = screen.queryByText(/chargement/i);
  if (loader) {
    await waitForElementToBeRemoved(loader);
  }
}

// test/utils/delay.ts

/**
 * Délai pour les tests asynchrones
 */
export function delay(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// test/utils/setup-test-env.ts
import { vi } from 'vitest';

/**
 * Configure l'environnement de test global
 */
export function setupTestEnv() {
  // Mock window.matchMedia
  Object.defineProperty(window, 'matchMedia', {
    writable: true,
    value: vi.fn().mockImplementation((query) => ({
      matches: false,
      media: query,
      onchange: null,
      addListener: vi.fn(),
      removeListener: vi.fn(),
      addEventListener: vi.fn(),
      removeEventListener: vi.fn(),
      dispatchEvent: vi.fn(),
    })),
  });

  // Mock IntersectionObserver
  global.IntersectionObserver = class IntersectionObserver {
    observe = vi.fn();
    disconnect = vi.fn();
    unobserve = vi.fn();
  } as any;
}

// test/utils/create-mock-router.ts
import { vi } from 'vitest';

/**
 * Crée un router mocké pour Next.js
 */
export function createMockRouter(overrides = {}) {
  return {
    push: vi.fn(),
    replace: vi.fn(),
    prefetch: vi.fn(),
    back: vi.fn(),
    pathname: '/',
    query: {},
    asPath: '/',
    route: '/',
    ...overrides,
  };
}

// test/utils/index.ts
export { createUser, createUsers } from './factories/user.factory';
export { renderWithProviders } from './render-with-providers';
export { waitForLoadingToFinish } from './wait-for-loading';
export { delay } from './delay';
export { setupTestEnv } from './setup-test-env';
export { createMockRouter } from './create-mock-router';

// Usage dans les tests

import { describe, it, expect, vi } from 'vitest';
import { screen } from '@testing-library/react';
import {
  renderWithProviders,
  createUser,
  waitForLoadingToFinish,
} from '@/test/utils';
import { UserList } from './user-list';
import * as userService from '../services/user.service';

vi.mock('../services/user.service');

describe('UserList', () => {
  it('should display users after loading', async () => {
    const users = [createUser({ name: 'Alice' }), createUser({ name: 'Bob' })];
    vi.mocked(userService.fetchUsers).mockResolvedValue(users);

    renderWithProviders(<UserList />);

    await waitForLoadingToFinish();

    expect(screen.getByText('Alice')).toBeInTheDocument();
    expect(screen.getByText('Bob')).toBeInTheDocument();
  });
});
```

## Variantes ou exceptions

* Les helpers très spécifiques à une feature peuvent rester dans `features/[feature]/test/`
* Pour des projets simples, les helpers peuvent être réduits au minimum
* Les librairies comme `@faker-js/faker` peuvent générer des données de test

## Liens / Références

* https://testing-library.com/docs/react-testing-library/setup
* https://github.com/faker-js/faker
* https://vitest.dev/guide/test-context.html
* Documentation interne : `/test/README.md`
