---
id: testing/async
category: testing
title: Tests asynchrones
status: draft
tags: [testing, async, promises, react-query, waitFor]
---

# Tests asynchrones

**Objectif** : Gérer correctement les tests asynchrones pour garantir des tests fiables et sans race conditions.
**Contexte** : À appliquer pour assurer la qualité et la fiabilité du code.

## Explication

Les tests asynchrones concernent tout code qui implique des Promises, des appels API, des timers ou des changements d'état différés. Ils nécessitent des techniques spécifiques pour attendre les résultats sans créer de tests flaky (instables).

**Scénarios asynchrones courants :**

* Appels API avec React Query ou fetch
* Hooks avec side-effects (useEffect)
* Timers (setTimeout, setInterval)
* Animations et transitions
* Chargement de données dynamiques
* Mises à jour d'état différées

**Outils pour gérer l'asynchrone :**

* **`waitFor`** : attendre qu'une condition soit remplie
* **`findBy*`** : queries asynchrones (équivalent de getBy + waitFor)
* **`waitForElementToBeRemoved`** : attendre la disparition d'un élément
* **`vi.useFakeTimers()`** : contrôler les timers dans les tests
* **`async/await`** : pour les opérations asynchrones

**Bonnes pratiques :**

* Toujours utiliser `async/await` dans les tests asynchrones
* Préférer `findBy*` pour les éléments qui apparaissent après un délai
* Utiliser `waitFor` pour les assertions sur des changements d'état
* Configurer un timeout approprié si nécessaire
* Nettoyer les timers et requêtes en suspens
* Éviter les `setTimeout` arbitraires dans les tests

**Erreurs à éviter :**

* Utiliser `getBy*` au lieu de `findBy*` pour des éléments asynchrones
* Oublier `await` devant les queries asynchrones
* Utiliser des timeouts fixes (`setTimeout(test, 1000)`) → anti-pattern
* Ne pas nettoyer les requêtes en cours après le test
* Tester avec de vraies API (toujours mocker)

## Exemple de mise en pratique

```tsx
// src/features/users/components/user-list.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import { renderWithProviders } from '@/test/utils/render-with-providers';
import { UserList } from './user-list';
import * as userService from '../services/user.service';

vi.mock('../services/user.service');

describe('UserList', () => {
  it('should display loading state then users', async () => {
    const mockUsers = [
      { id: '1', name: 'Alice' },
      { id: '2', name: 'Bob' },
    ];

    vi.mocked(userService.fetchUsers).mockResolvedValue(mockUsers);

    renderWithProviders(<UserList />);

    // État de chargement
    expect(screen.getByText(/chargement/i)).toBeInTheDocument();

    // Attendre l'affichage des utilisateurs (findBy = getBy + waitFor)
    expect(await screen.findByText('Alice')).toBeInTheDocument();
    expect(screen.getByText('Bob')).toBeInTheDocument();

    // Le loader a disparu
    expect(screen.queryByText(/chargement/i)).not.toBeInTheDocument();
  });

  it('should display error message on failure', async () => {
    vi.mocked(userService.fetchUsers).mockRejectedValue(
      new Error('Network error')
    );

    renderWithProviders(<UserList />);

    // Attendre le message d'erreur
    expect(await screen.findByText(/erreur/i)).toBeInTheDocument();
  });

  it('should refetch data after mutation', async () => {
    const user = userEvent.setup();
    const mockUsers = [{ id: '1', name: 'Alice' }];

    vi.mocked(userService.fetchUsers).mockResolvedValue(mockUsers);
    vi.mocked(userService.deleteUser).mockResolvedValue({ success: true });

    renderWithProviders(<UserList />);

    // Attendre l'affichage initial
    await screen.findByText('Alice');

    // Supprimer l'utilisateur
    const deleteButton = screen.getByRole('button', { name: /supprimer/i });
    await user.click(deleteButton);

    // Attendre la revalidation et la disparition
    await waitFor(() => {
      expect(screen.queryByText('Alice')).not.toBeInTheDocument();
    });
  });

  it('should handle debounced search', async () => {
    const user = userEvent.setup();
    vi.useFakeTimers();

    const mockUsers = [{ id: '1', name: 'Alice' }];
    vi.mocked(userService.searchUsers).mockResolvedValue(mockUsers);

    renderWithProviders(<UserList />);

    // Taper dans le champ de recherche
    const searchInput = screen.getByRole('textbox', { name: /rechercher/i });
    await user.type(searchInput, 'Ali');

    // Avancer les timers pour simuler le debounce (ex: 300ms)
    vi.advanceTimersByTime(300);

    // Attendre le résultat
    await waitFor(() => {
      expect(userService.searchUsers).toHaveBeenCalledWith('Ali');
    });

    expect(await screen.findByText('Alice')).toBeInTheDocument();

    vi.useRealTimers();
  });
});
```

## Variantes ou exceptions

* Pour des tests unitaires purs sans DOM, utiliser directement les Promises
* Les tests E2E utilisent leurs propres mécanismes d'attente (Playwright, Cypress)
* Pour des timers complexes, envisager de tester la logique séparément

## Liens / Références

* https://testing-library.com/docs/dom-testing-library/api-async/
* https://kentcdodds.com/blog/common-mistakes-with-react-testing-library#not-using-testing-librarys-async-utilities
* https://vitest.dev/api/vi.html#vi-usefaketimers
* Documentation interne : `/test/README.md`
