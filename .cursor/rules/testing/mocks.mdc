---
id: testing/mocks
category: testing
title: Centralisation des mocks
status: draft
tags: [testing, mocks, fixtures, test-data]
---

# Centralisation des mocks

**Objectif** : Centraliser les mocks et fixtures pour garantir la cohérence et la réutilisabilité des données de test.
**Contexte** : À appliquer pour assurer la qualité et la fiabilité du code.

## Explication

La centralisation des mocks permet d'éviter la duplication, de maintenir des données de test cohérentes et de faciliter la mise à jour des tests. Les mocks doivent être organisés par domaine et réutilisables à travers tous les tests.

**Organisation des mocks :**

```
test/
 └─ utils/
     └─ mocks/
         ├─ calendar.mock.ts
         ├─ user.mock.ts
         ├─ payment.mock.ts
         ├─ handlers.ts         # Handlers MSW pour API mocking
         └─ index.ts
```

**Types de mocks :**

* **Fixtures** : données de test réutilisables (objets, tableaux)
* **Factories** : fonctions pour générer des données de test avec valeurs par défaut
* **Handlers MSW** : mocks d'API avec Mock Service Worker
* **Mocks Vitest** : mocks de modules avec `vi.mock()`

**Bonnes pratiques :**

* Un fichier de mock par domaine métier
* Utiliser des factories pour créer des variations de données
* Nommer clairement les mocks (`mockUser`, `mockEvent`, `mockPayment`)
* Typer les mocks avec les mêmes types que le code de production
* Centraliser les handlers MSW dans un fichier dédié
* Exporter tous les mocks via `index.ts`

**Quand utiliser des mocks :**

* Appels API et services externes
* Modules tiers (Stripe, analytics, etc.)
* Fonctions avec side-effects (localStorage, Date.now(), Math.random())
* Dépendances lourdes ou lentes

**Quand NE PAS mocker :**

* Code interne du projet (composants, hooks, utils)
* Logique métier simple
* React Query, Context (utiliser les vrais providers)

## Exemple de mise en pratique

```ts
// test/utils/mocks/calendar.mock.ts
import type { Event } from '@/features/calendar/types';

export const mockEvent = (overrides?: Partial<Event>): Event => ({
  id: '1',
  title: 'Réunion d\'équipe',
  date: new Date('2025-10-27T10:00:00'),
  duration: 60,
  attendees: ['user-1', 'user-2'],
  ...overrides,
});

export const mockEvents: Event[] = [
  mockEvent({ id: '1', title: 'Réunion' }),
  mockEvent({ id: '2', title: 'Formation', date: new Date('2025-10-28') }),
  mockEvent({ id: '3', title: 'Review', date: new Date('2025-10-29') }),
];

// test/utils/mocks/handlers.ts
import { http, HttpResponse } from 'msw';
import { mockEvents } from './calendar.mock';

export const handlers = [
  http.get('/api/events', () => {
    return HttpResponse.json(mockEvents);
  }),

  http.post('/api/events', async ({ request }) => {
    const body = await request.json();
    return HttpResponse.json(mockEvent(body), { status: 201 });
  }),

  http.delete('/api/events/:id', ({ params }) => {
    return HttpResponse.json({ success: true });
  }),
];

// test/utils/mocks/index.ts
export * from './calendar.mock';
export * from './user.mock';
export * from './payment.mock';

// Usage dans un test
import { describe, it, expect } from 'vitest';
import { mockEvent, mockEvents } from '@/test/utils/mocks';

describe('EventList', () => {
  it('should render events', () => {
    const events = mockEvents;
    // ... test avec les données mockées
  });

  it('should handle custom event', () => {
    const customEvent = mockEvent({ title: 'Custom', duration: 120 });
    // ... test avec une variation
  });
});
```

## Variantes ou exceptions

* Pour des tests unitaires simples, des données inline peuvent suffire
* MSW n'est pas nécessaire si le projet n'a pas d'API
* Les mocks de modules externes peuvent être définis directement dans les tests si utilisés une seule fois

## Liens / Références

* https://vitest.dev/guide/mocking.html
* https://mswjs.io/docs/
* https://kentcdodds.com/blog/stop-mocking-fetch
* Documentation interne : `/test/README.md`
