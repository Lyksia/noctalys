---
alwaysApply: false
description: Define the structure and conventions for global types
---

# Types folder structure

**Objective**: Centralize **global TypeScript types** shared between multiple parts of the project.

**Context**: To apply for structuring projects according to a feature-first approach.

## Explanation

The `types/` folder groups **cross-cutting** and **reusable** TypeScript types: business types, utilities, API, etc.

Types specific to a feature should remain in `features/[name]/types.ts`.

**Organization:**

```
src/types/
 ├─ api.ts              # Types pour les réponses API
 ├─ models.ts           # Types métier globaux (User, Product, etc.)
 ├─ common.ts           # Types utilitaires partagés
 ├─ utils.ts            # Types utilitaires TypeScript avancés
 └─ index.ts            # Barrel pour exports
```

**Rules:**

- Prefer `type` for unions and strict types.
- Use `interface` for extensible objects.
- Prefix generic types with `T` (e.g., `TResponse<T>`).
- Avoid `any`: use `unknown` if the type is unknown.
- Always export types from `index.ts`.

## Practical Implementation Example

**Fichier `types/api.ts` :**

```ts
export type ApiResponse<T> = {
  data: T;
  message: string;
  success: boolean;
};

export type ApiError = {
  code: string;
  message: string;
  details?: Record<string, string[]>;
};

export type PaginatedResponse<T> = {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
};
```

**Fichier `types/models.ts` :**

```ts
export interface User {
  id: string;
  email: string;
  name: string;
  role: "admin" | "user";
  createdAt: Date;
  updatedAt: Date;
}

export interface Product {
  id: string;
  name: string;
  price: number;
  currency: string;
  stock: number;
}
```

**Fichier `types/utils.ts` :**

```ts
export type Nullable<T> = T | null;
export type Optional<T> = T | undefined;
export type ValueOf<T> = T[keyof T];
export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};
```

**Fichier `types/index.ts` :**

```ts
export type { ApiResponse, ApiError, PaginatedResponse } from "./api";
export type { User, Product } from "./models";
export type { Nullable, Optional, ValueOf, DeepPartial } from "./utils";
```

**Import from a feature:**

```ts
import type { User, ApiResponse, Nullable } from "@/types";

const user: Nullable<User> = null;
const response: ApiResponse<User> = await fetchUser();
```

## Variants or Exceptions

- Types specific to a feature should remain in `features/[name]/types.ts`.
- Types generated by Prisma should be imported from `@prisma/client`.
- Very small projects can merge all types in a single `types/index.ts` file.

## Links / References

- [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)
- [TypeScript Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
- Internal documentation: `references.md`
