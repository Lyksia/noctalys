---
alwaysApply: false
description: Clarify the use of type and interface for props
---

# Props: type vs interface

**Objective**: Clarify the use of `type` and `interface` for React component props to ensure consistency and readability.

**Context**: To apply for unifying code style and conventions.

## Explanation

TypeScript offers two ways to define props: `interface` and `type`. Each has its specific use cases.

**Rules:**

- **`interface`**: for classic and extensible props objects.
- **`type`**: for unions, intersections, or strict non-extensible props.
- **Naming**: always suffix with `Props` for component props.

**When to use `interface`:**

- Classic component props
- Need for extension or declaration merging
- Simple objects with properties

**When to use `type`:**

- Type unions (`string | number`)
- Intersections (`BaseProps & CustomProps`)
- Complex types (tuples, mapped types)
- Strict props with `Pick`, `Omit`, etc.

## Practical Implementation Example

**Classic props with `interface`:**

```tsx
// ✅ Good: interface for classic props
interface ButtonProps {
  children: React.ReactNode;
  onClick?: () => void;
  disabled?: boolean;
  variant?: "primary" | "secondary";
}

export function Button({ children, onClick, disabled, variant = "primary" }: ButtonProps) {
  return (
    <button onClick={onClick} disabled={disabled}>
      {children}
    </button>
  );
}
```

**Extension with `interface`:**

```tsx
// Base interface
interface BaseButtonProps {
  children: React.ReactNode;
  disabled?: boolean;
}

// Extension
interface IconButtonProps extends BaseButtonProps {
  icon: React.ReactNode;
  iconPosition?: "left" | "right";
}

export function IconButton({ children, icon, iconPosition = "left", disabled }: IconButtonProps) {
  return (
    <button disabled={disabled}>
      {iconPosition === "left" && icon}
      {children}
      {iconPosition === "right" && icon}
    </button>
  );
}
```

**Props with type unions (`type`):**

```tsx
// ✅ Good: type for unions
type ButtonVariant = "primary" | "secondary" | "outline" | "ghost";

interface ButtonProps {
  children: React.ReactNode;
  variant?: ButtonVariant;
}

// Or directly
type ButtonProps = {
  children: React.ReactNode;
  variant?: "primary" | "secondary" | "outline" | "ghost";
};
```

**Props with intersection (`type`):**

```tsx
type BaseProps = {
  className?: string;
  disabled?: boolean;
};

type ButtonSpecificProps = {
  onClick: () => void;
  variant: "primary" | "secondary";
};

// Intersection
type ButtonProps = BaseProps & ButtonSpecificProps;

export function Button({ className, disabled, onClick, variant }: ButtonProps) {
  return <button onClick={onClick} disabled={disabled} className={className} />;
}
```

**Props with `Pick` and `Omit` (`type`):**

```tsx
interface User {
  id: string;
  name: string;
  email: string;
  password: string;
  role: string;
}

// ✅ Good: type for Pick/Omit
type UserDisplayProps = {
  user: Pick<User, "name" | "email">;
};

type UserFormProps = {
  user: Omit<User, "password">;
};

export function UserDisplay({ user }: UserDisplayProps) {
  return (
    <div>
      {user.name} - {user.email}
    </div>
  );
}
```

**Props with Utility Types:**

```tsx
interface FormData {
  username: string;
  email: string;
  age: number;
}

// Partial: all fields optional
type FormUpdateProps = {
  data: Partial<FormData>;
  onUpdate: (data: Partial<FormData>) => void;
};

// Required: all fields required
type FormCreateProps = {
  data: Required<FormData>;
  onCreate: (data: FormData) => void;
};
```

**Props with React.ComponentProps:**

```tsx
// Reuse native HTML props
type ButtonProps = React.ComponentProps<"button"> & {
  variant?: "primary" | "secondary";
  isLoading?: boolean;
};

export function Button({ variant = "primary", isLoading, ...buttonProps }: ButtonProps) {
  return <button {...buttonProps} disabled={isLoading || buttonProps.disabled} />;
}

// With custom component
type CustomInputProps = React.ComponentProps<typeof Input> & {
  label: string;
  error?: string;
};
```

**Props with generics:**

```tsx
// Generic type for reusable components
interface SelectProps<T> {
  options: T[];
  value: T;
  onChange: (value: T) => void;
  getLabel: (option: T) => string;
}

export function Select<T>({ options, value, onChange, getLabel }: SelectProps<T>) {
  return (
    <select value={String(value)} onChange={(e) => onChange(options[Number(e.target.value)])}>
      {options.map((option, index) => (
        <option key={index} value={index}>
          {getLabel(option)}
        </option>
      ))}
    </select>
  );
}
```

**Optional vs required props:**

```tsx
interface CardProps {
  // Required
  title: string;
  content: string;

  // Optional
  footer?: React.ReactNode;
  className?: string;
  onClick?: () => void;

  // Default value (optional with default)
  variant?: "default" | "outlined";
}

export function Card({ title, content, footer, className, onClick, variant = "default" }: CardProps) {
  return (
    <div className={className} onClick={onClick}>
      <h2>{title}</h2>
      <p>{content}</p>
      {footer && <div>{footer}</div>}
    </div>
  );
}
```

**Declaration merging with `interface`:**

```tsx
// Declaration 1
interface ButtonProps {
  children: React.ReactNode;
  onClick: () => void;
}

// Declaration 2 (automatic merging)
interface ButtonProps {
  variant?: "primary" | "secondary";
}

// Result: ButtonProps = { children, onClick, variant? }
```

## Variants or Exceptions

- Very simple components can omit the `Props` suffix if the context is obvious.
- Existing projects may have different conventions but should converge towards this standard.

## Links / References

- [TypeScript: Interfaces vs Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces)
- [React TypeScript Cheatsheet](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example)
- Internal documentation: `references.md`
