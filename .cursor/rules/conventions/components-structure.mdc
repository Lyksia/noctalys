---
alwaysApply: false
description: Normalize the order and internal structure of components
---

# Component Order and Internal Structure

**Objective**: Normalize the order and internal structure of components to improve consistency and readability.

**Context**: To apply for unifying code style and conventions.

## Explanation

This rule details the precise order of elements inside a React functional component. Following this order facilitates reading and understanding the code.

**Order of elements:**

1. **Imports**
   - External libraries (React, Next.js, etc.)
   - Internal UI components
   - Project hooks and utils
   - Types and relative imports

2. **Types and interfaces**
   - Component props
   - Internal types

3. **Constants**
   - Component constants

4. **Component**
   - Props destructuring
   - State hooks (useState)
   - Context hooks (useContext, useAuth, etc.)
   - Ref hooks (useRef)
   - Memoization hooks (useMemo, useCallback)
   - Computed values
   - Event handlers
   - useEffect
   - Guard conditions (early returns)
   - JSX return

## Practical Implementation Example

**Import order:**

```tsx
// 1. React and external libraries
import { useState, useEffect, useCallback, useMemo } from "react";
import { useRouter } from "next/navigation";
import { useQuery, useMutation } from "@tanstack/react-query";

// 2. Internal UI components
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Dialog } from "@/components/ui/dialog";

// 3. Project hooks and utils
import { useAuth } from "@/features/auth/hooks";
import { useToast } from "@/hooks/use-toast";
import { cn } from "@/lib/utils";

// 4. Relative imports (feature)
import { fetchUsers, createUser } from "../services";
import type { User, CreateUserInput } from "../types";
```

**Hook order:**

```tsx
export function UserManager() {
  // 1. useState (local state)
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [selectedUser, setSelectedUser] = useState<User | null>(null);
  const [searchQuery, setSearchQuery] = useState("");

  // 2. useContext and custom context hooks
  const { user: currentUser } = useAuth();
  const { toast } = useToast();
  const router = useRouter();

  // 3. useRef
  const inputRef = useRef<HTMLInputElement>(null);
  const modalRef = useRef<HTMLDivElement>(null);

  // 4. React Query / SWR
  const { data: users, isLoading } = useQuery({
    queryKey: ["users", searchQuery],
    queryFn: () => fetchUsers({ search: searchQuery }),
  });

  const createMutation = useMutation({
    mutationFn: createUser,
    onSuccess: () => {
      toast({ title: "User created successfully" });
      setIsModalOpen(false);
    },
  });

  // 5. useMemo (computed values)
  const filteredUsers = useMemo(() => {
    if (!users) return [];
    return users.filter((u) => u.name.includes(searchQuery));
  }, [users, searchQuery]);

  const userCount = useMemo(() => filteredUsers.length, [filteredUsers]);

  // 6. useCallback (memoized handlers)
  const handleCreateUser = useCallback(
    (input: CreateUserInput) => {
      createMutation.mutate(input);
    },
    [createMutation]
  );

  const handleSelectUser = useCallback((user: User) => {
    setSelectedUser(user);
    setIsModalOpen(true);
  }, []);

  // 7. Event handlers (non-memoized)
  const handleSearch = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchQuery(e.target.value);
  };

  const handleCloseModal = () => {
    setIsModalOpen(false);
    setSelectedUser(null);
  };

  // 8. useEffect
  useEffect(() => {
    inputRef.current?.focus();
  }, []);

  useEffect(() => {
    if (isModalOpen) {
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = "auto";
    }

    return () => {
      document.body.style.overflow = "auto";
    };
  }, [isModalOpen]);

  // 9. Guards / Early returns
  if (!currentUser) {
    return <div>Please log in</div>;
  }

  if (isLoading) {
    return <div>Loading users...</div>;
  }

  // 10. JSX return
  return (
    <div>
      <Input ref={inputRef} value={searchQuery} onChange={handleSearch} placeholder="Search users" />
      <p>Found {userCount} users</p>
      <UserList users={filteredUsers} onSelectUser={handleSelectUser} />
      {isModalOpen && <UserModal user={selectedUser} onClose={handleCloseModal} />}
    </div>
  );
}
```

**Logical grouping:**

```tsx
export function ProductForm() {
  // === STATE ===
  const [name, setName] = useState("");
  const [price, setPrice] = useState(0);
  const [category, setCategory] = useState("");
  const [errors, setErrors] = useState<Record<string, string>>({});

  // === HOOKS ===
  const { user } = useAuth();
  const router = useRouter();

  // === COMPUTED VALUES ===
  const isValid = useMemo(() => {
    return name.length > 0 && price > 0 && category.length > 0;
  }, [name, price, category]);

  const formattedPrice = useMemo(() => {
    return new Intl.NumberFormat("en-US", { style: "currency", currency: "USD" }).format(price);
  }, [price]);

  // === HANDLERS ===
  const handleNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setName(e.target.value);
  };

  const handlePriceChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setPrice(Number(e.target.value));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    // Logic here
  };

  // === EFFECTS ===
  useEffect(() => {
    // Load initial data
  }, []);

  // === RENDER ===
  return <form onSubmit={handleSubmit}>{/* Form fields */}</form>;
}
```

**JSX order:**

```tsx
export function ProductCard({ product }: ProductCardProps) {
  return (
    <div className="product-card">
      {/* 1. Header */}
      <header>
        <h3>{product.name}</h3>
        <span>{product.category}</span>
      </header>

      {/* 2. Image */}
      <img src={product.image} alt={product.name} />

      {/* 3. Content */}
      <div className="content">
        <p>{product.description}</p>
      </div>

      {/* 4. Footer / Actions */}
      <footer>
        <span className="price">{product.price}</span>
        <Button>Add to Cart</Button>
      </footer>
    </div>
  );
}
```

**Props order:**

```tsx
// Recommended props order in JSX
<Button
  // 1. Identifier
  id="submit-button"
  key="submit"
  
  // 2. Type / Variant
  type="submit"
  variant="primary"
  size="lg"
  
  // 3. State
  disabled={isLoading}
  loading={isLoading}
  
  // 4. Events
  onClick={handleSubmit}
  onFocus={handleFocus}
  
  // 5. Style / Class
  className="custom-class"
  style={{ marginTop: 10 }}
  
  // 6. Accessibility
  aria-label="Submit form"
  role="button"
>
  Submit
</Button>
```

## Variants or Exceptions

- The order can be adjusted slightly according to specific component needs.
- Very simple components can omit certain groupings.

## Links / References

- [React Hooks Order](https://react.dev/reference/react)
- [Clean Code in React](https://react.dev/learn/thinking-in-react)
- Internal documentation: `references.md`
