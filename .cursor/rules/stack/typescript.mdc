---
alwaysApply: false
description: TypeScript rules and standards for code typing
---

# TypeScript

**Objective**: Standardize TypeScript usage to ensure type-safe, maintainable, and consistent code.

**Context**: To apply for standardizing the use of this technology in projects.

## Explanation

TypeScript is the language used for all projects. Prioritize **strict typing** and avoid `any`.

**Key Principles:**

- **Strict mode**: always enable `strict: true` in `tsconfig.json`.
- **No `any`**: use `unknown` if the type is unknown.
- **Explicit typing**: type function parameters and return values.
- **Interfaces vs Types**: `interface` for extensible objects, `type` for unions.
- **Generics**: use generics for reusable functions.
- **Utility Types**: leverage TypeScript utility types (`Partial`, `Pick`, `Omit`, etc.).

**Configuration `tsconfig.json` :**

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  }
}
```

## Practical Implementation Example

**Function typing:**

```ts
// ✅ Good: explicit types
function calculateTotal(items: number[], tax: number): number {
  return items.reduce((sum, item) => sum + item, 0) * (1 + tax);
}

// ❌ Bad: implicit types
function calculateTotal(items, tax) {
  return items.reduce((sum, item) => sum + item, 0) * (1 + tax);
}
```

**Interface vs Type :**

```ts
// Interface pour les objets extensibles
interface User {
  id: string;
  name: string;
  email: string;
}

interface Admin extends User {
  role: "admin";
  permissions: string[];
}

// Type pour les unions et types stricts
type Status = "pending" | "approved" | "rejected";
type ApiResponse<T> = { data: T; success: true } | { error: string; success: false };
```

**Generics:**

```ts
// Reusable generic function
function findById<T extends { id: string }>(items: T[], id: string): T | undefined {
  return items.find((item) => item.id === id);
}

const users: User[] = [{ id: "1", name: "John", email: "john@example.com" }];
const user = findById(users, "1"); // Type: User | undefined
```

**Utility Types :**

```ts
interface User {
  id: string;
  name: string;
  email: string;
  password: string;
}

// Partial : tous les champs optionnels
type UserUpdate = Partial<User>;

// Pick : sélectionner certains champs
type UserPublic = Pick<User, "id" | "name" | "email">;

// Omit : exclure certains champs
type UserWithoutPassword = Omit<User, "password">;

// Required : tous les champs requis
type UserRequired = Required<UserUpdate>;
```

**Avoid `any`:**

```ts
// ❌ Bad: any
function handleData(data: any) {
  console.log(data.name);
}

// ✅ Good: unknown + type guard
function handleData(data: unknown) {
  if (typeof data === "object" && data !== null && "name" in data) {
    console.log(data.name);
  }
}

// ✅ Better: defined type
interface Data {
  name: string;
}

function handleData(data: Data) {
  console.log(data.name);
}
```

## Variants or Exceptions

- Configuration files (`.js`, `.mjs`) may not be typed.
- Projects in progressive migration can temporarily allow `any`, but must replace it quickly.

## Links / References

- [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)
- [TypeScript Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
- [TypeScript Best Practices](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html)
