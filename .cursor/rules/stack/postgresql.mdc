---
alwaysApply: false
description: PostgreSQL best practices
---

# PostgreSQL

**Objectif** : Standardiser l'usage de PostgreSQL en adoptant les bonnes pratiques pour la performance, la sécurité et la maintenabilité.

**Contexte** : À appliquer pour standardiser l'usage de cette technologie dans les projets.

## Explication

PostgreSQL est le système de gestion de base de données utilisé pour tous les projets. Il fournit des performances élevées, des fonctionnalités avancées et une fiabilité éprouvée.

**Principes clés :**

- **Connexion sécurisée** : toujours utiliser SSL en production.
- **Indexes** : créer des indexes sur les colonnes fréquemment interrogées.
- **Contraintes** : utiliser les contraintes de base de données (UNIQUE, CHECK, etc.).
- **Transactions** : utiliser les transactions pour les opérations critiques.
- **Backups** : configurer des backups automatiques.

## Exemple de mise en pratique

**Configuration de connexion :**

```env
# .env.local
DATABASE_URL="postgresql://user:password@localhost:5432/mydb?schema=public"

# Production avec SSL
DATABASE_URL="postgresql://user:password@host:5432/mydb?sslmode=require"
```

**Bonnes pratiques de schéma :**

```prisma
// prisma/schema.prisma
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Index sur email pour les recherches fréquentes
  @@index([email])
  // Index composé pour les requêtes complexes
  @@index([createdAt, email])
}

model Product {
  id          String   @id @default(cuid())
  name        String
  price       Decimal  @db.Decimal(10, 2) // Précision pour les montants
  stock       Int      @default(0)
  categoryId  String
  category    Category @relation(fields: [categoryId], references: [id])
  createdAt   DateTime @default(now())

  // Contrainte : le stock ne peut pas être négatif
  @@check(stock >= 0, name: "positive_stock")
  @@index([categoryId])
}
```

**Utilisation des transactions :**

```ts
// src/features/orders/services/order-service.ts
import { prisma } from "@/lib/prisma";

export async function createOrderWithStock(
  userId: string,
  productId: string,
  quantity: number
) {
  return prisma.$transaction(async (tx) => {
    // 1. Vérifier le stock
    const product = await tx.product.findUnique({
      where: { id: productId },
    });

    if (!product || product.stock < quantity) {
      throw new Error("Insufficient stock");
    }

    // 2. Décrémenter le stock
    await tx.product.update({
      where: { id: productId },
      data: {
        stock: {
          decrement: quantity,
        },
      },
    });

    // 3. Créer la commande
    const order = await tx.order.create({
      data: {
        userId,
        productId,
        quantity,
        totalPrice: product.price * quantity,
      },
    });

    return order;
  });
}
```

**Requêtes optimisées :**

```ts
// ❌ Mauvais : N+1 queries
const users = await prisma.user.findMany();
for (const user of users) {
  const posts = await prisma.post.findMany({ where: { authorId: user.id } });
}

// ✅ Bon : une seule requête avec include
const users = await prisma.user.findMany({
  include: {
    posts: true,
  },
});
```

**Pagination efficace :**

```ts
// src/features/posts/services/posts-db.ts
import { prisma } from "@/lib/prisma";

export async function findPostsPaginated(page = 1, limit = 20) {
  const skip = (page - 1) * limit;

  const [posts, total] = await Promise.all([
    prisma.post.findMany({
      skip,
      take: limit,
      orderBy: { createdAt: "desc" },
      include: {
        author: {
          select: { id: true, name: true, email: true },
        },
      },
    }),
    prisma.post.count(),
  ]);

  return {
    data: posts,
    pagination: {
      page,
      limit,
      total,
      totalPages: Math.ceil(total / limit),
    },
  };
}
```

**Full-text search :**

```prisma
model Post {
  id      String @id @default(cuid())
  title   String
  content String

  @@index([title], type: Hash)
  @@fulltext([title, content])
}
```

```ts
export async function searchPosts(query: string) {
  return prisma.post.findMany({
    where: {
      OR: [
        { title: { contains: query, mode: "insensitive" } },
        { content: { contains: query, mode: "insensitive" } },
      ],
    },
  });
}
```

**Gestion des connexions :**

```ts
// src/lib/prisma.ts
import { PrismaClient } from "@prisma/client";

export const prisma = new PrismaClient({
  log: process.env.NODE_ENV === "development" ? ["query", "error", "warn"] : ["error"],
  datasources: {
    db: {
      url: process.env.DATABASE_URL,
    },
  },
});

// Fermer proprement la connexion
process.on("beforeExit", async () => {
  await prisma.$disconnect();
});
```

**Backups (via pg_dump) :**

```bash
# Backup manuel
pg_dump -U username -h localhost -d mydb > backup.sql

# Restore
psql -U username -h localhost -d mydb < backup.sql
```

## Variantes ou exceptions

- Les projets très simples peuvent utiliser SQLite en développement.
- Les projets avec des besoins NoSQL peuvent utiliser MongoDB en complément.

## Liens / Références

- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
- [Prisma + PostgreSQL](https://www.prisma.io/docs/concepts/database-connectors/postgresql)
- [PostgreSQL Performance Tips](https://wiki.postgresql.org/wiki/Performance_Optimization)
