---
id: data/forms
category: data
title: Gestion des formulaires
status: draft
tags: [react-hook-form, zod, forms, validation]
alwaysApply: false
description: Frame form management and validation
---

# Gestion des formulaires

**Objectif** : Encadrer la gestion des formulaires avec React Hook Form et Zod pour garantir une validation robuste et une bonne expérience utilisateur.

**Contexte** : À appliquer pour garantir la cohérence de la gestion de l'état et des données.

## Explication

React Hook Form gère l'état et la soumission des formulaires avec des performances optimales. Zod assure la validation stricte des données.

**Principes clés :**

- **React Hook Form pour tous les formulaires** : pas de useState manuel
- **Zod pour la validation** : schémas réutilisables et typés
- **Validation côté client ET serveur** : double vérification
- **Feedback utilisateur immédiat** : affichage des erreurs en temps réel
- **Typage strict** : types dérivés des schémas Zod

## Exemple de mise en pratique

**Formulaire simple :**

```tsx
// src/features/users/components/create-user-form.tsx
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { createUserSchema } from "../types";
import type { CreateUserInput } from "../types";
import { useCreateUser } from "../hooks";

export function CreateUserForm() {
  const createMutation = useCreateUser();

  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<CreateUserInput>({
    resolver: zodResolver(createUserSchema),
  });

  const onSubmit = async (data: CreateUserInput) => {
    try {
      await createMutation.mutateAsync(data);
      toast.success("User created successfully");
    } catch (error) {
      toast.error("Failed to create user");
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" type="email" {...register("email")} />
        {errors.email && <span className="text-red-500">{errors.email.message}</span>}
      </div>

      <div>
        <label htmlFor="name">Name</label>
        <input id="name" {...register("name")} />
        {errors.name && <span className="text-red-500">{errors.name.message}</span>}
      </div>

      <button type="submit" disabled={isSubmitting || createMutation.isPending}>
        {isSubmitting ? "Creating..." : "Create User"}
      </button>
    </form>
  );
}
```

**Formulaire avec valeurs par défaut :**

```tsx
// src/features/users/components/edit-user-form.tsx
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { updateUserSchema } from "../types";
import type { User, UpdateUserInput } from "../types";
import { useUpdateUser } from "../hooks";

interface EditUserFormProps {
  user: User;
}

export function EditUserForm({ user }: EditUserFormProps) {
  const updateMutation = useUpdateUser();

  const {
    register,
    handleSubmit,
    formState: { errors, isDirty },
  } = useForm<UpdateUserInput>({
    resolver: zodResolver(updateUserSchema),
    defaultValues: {
      email: user.email,
      name: user.name,
      role: user.role,
    },
  });

  const onSubmit = async (data: UpdateUserInput) => {
    await updateMutation.mutateAsync({ id: user.id, data });
    toast.success("User updated");
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register("email")} />
      {errors.email && <span>{errors.email.message}</span>}

      <input {...register("name")} />
      {errors.name && <span>{errors.name.message}</span>}

      <select {...register("role")}>
        <option value="USER">User</option>
        <option value="ADMIN">Admin</option>
      </select>
      {errors.role && <span>{errors.role.message}</span>}

      <button type="submit" disabled={!isDirty || updateMutation.isPending}>
        Save Changes
      </button>
    </form>
  );
}
```

**Formulaire avec champs complexes :**

```tsx
// src/features/posts/components/create-post-form.tsx
import { useForm, Controller } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { createPostSchema } from "../types";
import type { CreatePostInput } from "../types";

export function CreatePostForm() {
  const {
    register,
    handleSubmit,
    control,
    watch,
    formState: { errors },
  } = useForm<CreatePostInput>({
    resolver: zodResolver(createPostSchema),
  });

  const content = watch("content");

  const onSubmit = async (data: CreatePostInput) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register("title")} placeholder="Title" />
      {errors.title && <span>{errors.title.message}</span>}

      <Controller
        name="content"
        control={control}
        render={({ field }) => (
          <div>
            <textarea {...field} rows={10} />
            <div className="text-sm text-gray-500">{content?.length || 0} characters</div>
          </div>
        )}
      />
      {errors.content && <span>{errors.content.message}</span>}

      <label>
        <input type="checkbox" {...register("published")} />
        Publish immediately
      </label>

      <button type="submit">Create Post</button>
    </form>
  );
}
```

**Formulaire avec champs dynamiques :**

```tsx
// src/features/products/components/product-variant-form.tsx
import { useForm, useFieldArray } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { productWithVariantsSchema } from "../types";
import type { ProductWithVariantsInput } from "../types";

export function ProductVariantForm() {
  const {
    register,
    control,
    handleSubmit,
    formState: { errors },
  } = useForm<ProductWithVariantsInput>({
    resolver: zodResolver(productWithVariantsSchema),
    defaultValues: {
      name: "",
      variants: [{ size: "", color: "", price: 0 }],
    },
  });

  const { fields, append, remove } = useFieldArray({
    control,
    name: "variants",
  });

  const onSubmit = (data: ProductWithVariantsInput) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register("name")} placeholder="Product name" />
      {errors.name && <span>{errors.name.message}</span>}

      <div>
        <h3>Variants</h3>
        {fields.map((field, index) => (
          <div key={field.id}>
            <input {...register(`variants.${index}.size`)} placeholder="Size" />
            <input {...register(`variants.${index}.color`)} placeholder="Color" />
            <input {...register(`variants.${index}.price`, { valueAsNumber: true })} type="number" placeholder="Price" />
            <button type="button" onClick={() => remove(index)}>
              Remove
            </button>
            {errors.variants?.[index] && <span>Invalid variant</span>}
          </div>
        ))}
        <button type="button" onClick={() => append({ size: "", color: "", price: 0 })}>
          Add Variant
        </button>
      </div>

      <button type="submit">Submit</button>
    </form>
  );
}
```

**Formulaire avec Shadcn UI :**

```tsx
// src/features/users/components/user-form.tsx
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Form, FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from "@/ui/components/form";
import { Input } from "@/ui/components/input";
import { Button } from "@/ui/components/button";
import { createUserSchema } from "../types";
import type { CreateUserInput } from "../types";

export function UserForm() {
  const form = useForm<CreateUserInput>({
    resolver: zodResolver(createUserSchema),
    defaultValues: {
      email: "",
      name: "",
    },
  });

  const onSubmit = (data: CreateUserInput) => {
    console.log(data);
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <FormControl>
                <Input type="email" placeholder="john@example.com" {...field} />
              </FormControl>
              <FormDescription>Your email address</FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Name</FormLabel>
              <FormControl>
                <Input placeholder="John Doe" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <Button type="submit" disabled={form.formState.isSubmitting}>
          Submit
        </Button>
      </form>
    </Form>
  );
}
```

**Validation personnalisée :**

```ts
// src/features/auth/types.ts
import { z } from "zod";

export const registerSchema = z
  .object({
    email: z.string().email("Invalid email"),
    password: z.string().min(8, "Password must be at least 8 characters"),
    confirmPassword: z.string(),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ["confirmPassword"],
  });

export type RegisterInput = z.infer<typeof registerSchema>;
```

**Validation asynchrone :**

```tsx
// src/features/users/components/register-form.tsx
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { registerSchema } from "../types";
import type { RegisterInput } from "../types";

async function checkEmailAvailable(email: string): Promise<boolean> {
  const response = await fetch(`/api/users/check-email?email=${email}`);
  const data = await response.json();
  return data.available;
}

export function RegisterForm() {
  const {
    register,
    handleSubmit,
    setError,
    formState: { errors, isSubmitting },
  } = useForm<RegisterInput>({
    resolver: zodResolver(registerSchema),
  });

  const onSubmit = async (data: RegisterInput) => {
    // Validation asynchrone côté client
    const isAvailable = await checkEmailAvailable(data.email);

    if (!isAvailable) {
      setError("email", {
        type: "manual",
        message: "This email is already taken",
      });
      return;
    }

    // Soumettre le formulaire
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register("email")} />
      {errors.email && <span>{errors.email.message}</span>}

      <input type="password" {...register("password")} />
      {errors.password && <span>{errors.password.message}</span>}

      <input type="password" {...register("confirmPassword")} />
      {errors.confirmPassword && <span>{errors.confirmPassword.message}</span>}

      <button type="submit" disabled={isSubmitting}>
        Register
      </button>
    </form>
  );
}
```

**Reset et manipulation du formulaire :**

```tsx
// src/features/products/components/product-form.tsx
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { productSchema } from "../types";
import type { ProductInput } from "../types";

export function ProductForm() {
  const { register, handleSubmit, reset, setValue, watch } = useForm<ProductInput>({
    resolver: zodResolver(productSchema),
  });

  const price = watch("price");

  const handleDiscount = () => {
    // Appliquer 10% de réduction
    const discountedPrice = price * 0.9;
    setValue("price", discountedPrice);
  };

  const onSubmit = (data: ProductInput) => {
    console.log(data);
    // Reset après soumission
    reset();
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register("name")} />
      <input {...register("price", { valueAsNumber: true })} type="number" />

      <button type="button" onClick={handleDiscount}>
        Apply 10% Discount
      </button>
      <button type="button" onClick={() => reset()}>
        Clear Form
      </button>
      <button type="submit">Submit</button>
    </form>
  );
}
```

**Formulaire avec upload de fichier :**

```tsx
// src/features/uploads/components/upload-form.tsx
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";

const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
const ACCEPTED_FILE_TYPES = ["image/jpeg", "image/png", "image/webp"];

const uploadSchema = z.object({
  title: z.string().min(1, "Title is required"),
  file: z
    .instanceof(FileList)
    .refine((files) => files.length > 0, "File is required")
    .refine((files) => files[0]?.size <= MAX_FILE_SIZE, "Max file size is 5MB")
    .refine((files) => ACCEPTED_FILE_TYPES.includes(files[0]?.type), "Only .jpg, .png and .webp files are accepted"),
});

type UploadInput = z.infer<typeof uploadSchema>;

export function UploadForm() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<UploadInput>({
    resolver: zodResolver(uploadSchema),
  });

  const onSubmit = async (data: UploadInput) => {
    const formData = new FormData();
    formData.append("title", data.title);
    formData.append("file", data.file[0]);

    await fetch("/api/upload", {
      method: "POST",
      body: formData,
    });
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register("title")} />
      {errors.title && <span>{errors.title.message}</span>}

      <input type="file" {...register("file")} accept="image/*" />
      {errors.file && <span>{errors.file.message}</span>}

      <button type="submit">Upload</button>
    </form>
  );
}
```

**Formulaire multi-étapes :**

```tsx
// src/features/onboarding/components/multi-step-form.tsx
import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { onboardingSchema } from "../types";
import type { OnboardingInput } from "../types";

export function MultiStepForm() {
  const [step, setStep] = useState(1);

  const {
    register,
    handleSubmit,
    trigger,
    formState: { errors },
  } = useForm<OnboardingInput>({
    resolver: zodResolver(onboardingSchema),
    mode: "onBlur",
  });

  const handleNext = async () => {
    let isValid = false;

    if (step === 1) {
      isValid = await trigger(["email", "password"]);
    } else if (step === 2) {
      isValid = await trigger(["name", "company"]);
    }

    if (isValid) {
      setStep((prev) => prev + 1);
    }
  };

  const onSubmit = (data: OnboardingInput) => {
    console.log("Final data:", data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {step === 1 && (
        <div>
          <h2>Step 1: Account</h2>
          <input {...register("email")} />
          {errors.email && <span>{errors.email.message}</span>}

          <input type="password" {...register("password")} />
          {errors.password && <span>{errors.password.message}</span>}

          <button type="button" onClick={handleNext}>
            Next
          </button>
        </div>
      )}

      {step === 2 && (
        <div>
          <h2>Step 2: Profile</h2>
          <input {...register("name")} />
          {errors.name && <span>{errors.name.message}</span>}

          <input {...register("company")} />
          {errors.company && <span>{errors.company.message}</span>}

          <button type="button" onClick={() => setStep(1)}>
            Back
          </button>
          <button type="button" onClick={handleNext}>
            Next
          </button>
        </div>
      )}

      {step === 3 && (
        <div>
          <h2>Step 3: Confirmation</h2>
          <button type="button" onClick={() => setStep(2)}>
            Back
          </button>
          <button type="submit">Complete</button>
        </div>
      )}
    </form>
  );
}
```

## Variantes ou exceptions

- Les formulaires très simples (1-2 champs) peuvent utiliser un state local sans React Hook Form.
- Les Server Actions Next.js peuvent valider avec Zod côté serveur sans React Hook Form.

## Liens / Références

- [React Hook Form Documentation](https://react-hook-form.com/)
- [Zod Documentation](https://zod.dev/)
- [@hookform/resolvers](https://github.com/react-hook-form/resolvers)
- Documentation interne : `references.md`
