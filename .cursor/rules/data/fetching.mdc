---
alwaysApply: false
description: Standardize data fetching (React Query + Axios)
---

# Récupération de données

**Objectif** : Standardiser la récupération de données avec React Query et Axios pour garantir cohérence et maintenabilité.

**Contexte** : À appliquer pour garantir la cohérence de la gestion de l'état et des données.

## Explication

La récupération de données doit toujours passer par React Query côté client. Les services API utilisent Axios pour les requêtes HTTP.

**Architecture :**

1. **Services** (`services/`) : fonctions qui appellent l'API avec Axios
2. **Hooks** (`hooks/`) : hooks React Query qui utilisent les services
3. **Composants** : utilisent les hooks, jamais les services directement

**Règles :**

- **Jamais de fetch direct dans un composant**
- **React Query pour toutes les données serveur**
- **Axios pour les appels HTTP**
- **Typage strict** des réponses
- **Gestion d'erreurs cohérente**

## Exemple de mise en pratique

**Service API avec Axios :**

```ts
// src/features/users/services/users-api.ts
import { apiClient } from "@/lib/axios";
import type { User, CreateUserInput, UpdateUserInput } from "../types";

export async function fetchUsers(): Promise<User[]> {
  const { data } = await apiClient.get<User[]>("/users");
  return data;
}

export async function fetchUserById(id: string): Promise<User> {
  const { data } = await apiClient.get<User>(`/users/${id}`);
  return data;
}

export async function createUser(input: CreateUserInput): Promise<User> {
  const { data } = await apiClient.post<User>("/users", input);
  return data;
}

export async function updateUser(id: string, input: UpdateUserInput): Promise<User> {
  const { data } = await apiClient.patch<User>(`/users/${id}`, input);
  return data;
}

export async function deleteUser(id: string): Promise<void> {
  await apiClient.delete(`/users/${id}`);
}
```

**Hook React Query :**

```ts
// src/features/users/hooks/use-users.ts
import { useQuery } from "@tanstack/react-query";
import { fetchUsers } from "../services";
import { userKeys } from "../queries";

export function useUsers() {
  return useQuery({
    queryKey: userKeys.all,
    queryFn: fetchUsers,
  });
}
```

**Hook avec paramètres :**

```ts
// src/features/users/hooks/use-users.ts
import { useQuery } from "@tanstack/react-query";
import { fetchUsers } from "../services";
import { userKeys } from "../queries";

interface UseUsersOptions {
  search?: string;
  role?: string;
  page?: number;
  limit?: number;
}

export function useUsers(options: UseUsersOptions = {}) {
  return useQuery({
    queryKey: userKeys.list(JSON.stringify(options)),
    queryFn: () => fetchUsers(options),
    enabled: true, // Toujours actif par défaut
  });
}

// Service correspondant
export async function fetchUsers(params: UseUsersOptions = {}): Promise<User[]> {
  const { data } = await apiClient.get<User[]>("/users", { params });
  return data;
}
```

**Composant utilisant le hook :**

```tsx
// src/features/users/components/user-list.tsx
import { useUsers } from "../hooks";

export function UserList() {
  const { data: users, isLoading, error } = useUsers();

  if (isLoading) {
    return <div>Loading users...</div>;
  }

  if (error) {
    return <div>Error: {error.message}</div>;
  }

  return (
    <ul>
      {users?.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

**Gestion d'erreurs dans le service :**

```ts
// src/features/users/services/users-api.ts
import { apiClient } from "@/lib/axios";
import { AxiosError } from "axios";

export async function fetchUsers(): Promise<User[]> {
  try {
    const { data } = await apiClient.get<User[]>("/users");
    return data;
  } catch (error) {
    if (error instanceof AxiosError) {
      // Log l'erreur ou envoyer à un service de monitoring
      console.error("API Error:", error.response?.data);

      // Transformer l'erreur pour le client
      throw new Error(error.response?.data?.message || "Failed to fetch users");
    }
    throw error;
  }
}
```

**Validation de réponse avec Zod :**

```ts
// src/features/users/services/users-api.ts
import { apiClient } from "@/lib/axios";
import { z } from "zod";

const userSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
  role: z.enum(["admin", "user"]),
});

const usersResponseSchema = z.array(userSchema);

export async function fetchUsers(): Promise<User[]> {
  const { data } = await apiClient.get("/users");

  // Valider la réponse
  const validated = usersResponseSchema.parse(data);
  return validated;
}
```

**Service avec paramètres de recherche :**

```ts
// src/features/products/services/products-api.ts
import { apiClient } from "@/lib/axios";
import type { Product, ProductFilters } from "../types";

export async function searchProducts(filters: ProductFilters): Promise<Product[]> {
  const params = new URLSearchParams();

  if (filters.query) params.append("q", filters.query);
  if (filters.category) params.append("category", filters.category);
  if (filters.minPrice) params.append("minPrice", filters.minPrice.toString());
  if (filters.maxPrice) params.append("maxPrice", filters.maxPrice.toString());

  const { data } = await apiClient.get<Product[]>(`/products/search?${params}`);
  return data;
}

// Hook correspondant
export function useSearchProducts(filters: ProductFilters) {
  return useQuery({
    queryKey: ["products", "search", filters],
    queryFn: () => searchProducts(filters),
    enabled: !!filters.query, // Ne fetch que si query existe
  });
}
```

**Service avec annulation de requête :**

```ts
// src/features/users/services/users-api.ts
import { apiClient } from "@/lib/axios";

export async function fetchUsers(signal?: AbortSignal): Promise<User[]> {
  const { data } = await apiClient.get<User[]>("/users", { signal });
  return data;
}

// Hook avec annulation automatique
export function useUsers() {
  return useQuery({
    queryKey: ["users"],
    queryFn: ({ signal }) => fetchUsers(signal),
  });
}
```

**Service avec retry logic :**

```ts
// src/features/users/hooks/use-users.ts
import { useQuery } from "@tanstack/react-query";
import { fetchUsers } from "../services";

export function useUsers() {
  return useQuery({
    queryKey: ["users"],
    queryFn: fetchUsers,
    retry: (failureCount, error) => {
      // Ne pas retry sur 4xx errors
      if (error instanceof AxiosError && error.response?.status && error.response.status < 500) {
        return false;
      }
      // Retry jusqu'à 3 fois pour 5xx errors
      return failureCount < 3;
    },
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000), // Exponential backoff
  });
}
```

**Service avec transformation de données :**

```ts
// src/features/products/services/products-api.ts
import { apiClient } from "@/lib/axios";
import type { Product, ProductDTO } from "../types";

export async function fetchProducts(): Promise<Product[]> {
  const { data } = await apiClient.get<ProductDTO[]>("/products");

  // Transformer les données du serveur
  return data.map((dto) => ({
    id: dto.id,
    name: dto.name,
    price: dto.price / 100, // Convertir centimes en euros
    category: dto.category,
    imageUrl: dto.image_url, // Convertir snake_case en camelCase
    createdAt: new Date(dto.created_at),
  }));
}
```

**Hook avec états de chargement multiples :**

```tsx
// src/features/dashboard/components/dashboard.tsx
import { useUsers } from "@/features/users/hooks";
import { useProducts } from "@/features/products/hooks";
import { useOrders } from "@/features/orders/hooks";

export function Dashboard() {
  const usersQuery = useUsers();
  const productsQuery = useProducts();
  const ordersQuery = useOrders();

  // Combiner les états
  const isLoading = usersQuery.isLoading || productsQuery.isLoading || ordersQuery.isLoading;
  const hasError = usersQuery.error || productsQuery.error || ordersQuery.error;

  if (isLoading) return <div>Loading dashboard...</div>;
  if (hasError) return <div>Failed to load dashboard</div>;

  return (
    <div>
      <h1>Dashboard</h1>
      <StatsCard users={usersQuery.data} products={productsQuery.data} orders={ordersQuery.data} />
    </div>
  );
}
```

**Service avec headers personnalisés :**

```ts
// src/features/reports/services/reports-api.ts
import { apiClient } from "@/lib/axios";

export async function downloadReport(reportId: string): Promise<Blob> {
  const { data } = await apiClient.get(`/reports/${reportId}/download`, {
    responseType: "blob",
    headers: {
      Accept: "application/pdf",
    },
  });
  return data;
}
```

**Hook avec refetch interval :**

```ts
// src/features/orders/hooks/use-order-status.ts
import { useQuery } from "@tanstack/react-query";
import { fetchOrderStatus } from "../services";

export function useOrderStatus(orderId: string) {
  return useQuery({
    queryKey: ["orders", orderId, "status"],
    queryFn: () => fetchOrderStatus(orderId),
    refetchInterval: (data) => {
      // Stop polling si le statut est final
      if (data?.status === "delivered" || data?.status === "cancelled") {
        return false;
      }
      // Sinon, poll toutes les 5 secondes
      return 5000;
    },
  });
}
```

**Pattern Query Factory :**

```ts
// src/features/users/queries.ts
import { fetchUsers, fetchUserById } from "./services";

export const userQueries = {
  all: () => ({
    queryKey: ["users"],
    queryFn: fetchUsers,
  }),
  detail: (id: string) => ({
    queryKey: ["users", id],
    queryFn: () => fetchUserById(id),
  }),
};

// Usage
import { useQuery } from "@tanstack/react-query";
import { userQueries } from "../queries";

export function useUser(id: string) {
  return useQuery(userQueries.detail(id));
}
```

## Variantes ou exceptions

- Les Server Components Next.js utilisent `fetch()` natif, pas React Query.
- Les mutations sont couvertes dans `data/mutations.mdc`.

## Liens / Références

- [TanStack Query Documentation](https://tanstack.com/query/latest)
- [Axios Documentation](https://axios-http.com/)
- Documentation interne : `references.md`
