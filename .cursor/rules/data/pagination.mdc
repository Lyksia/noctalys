---
id: data/pagination
category: data
title: Patterns de pagination
status: draft
tags: [pagination, react-query, api, performance]
alwaysApply: false
description: Standardize pagination patterns
---

# Patterns de pagination

**Objectif** : Standardiser les patterns de pagination pour gérer efficacement de grandes quantités de données avec React Query.

**Contexte** : À appliquer pour garantir la cohérence de la gestion de l'état et des données.

## Explication

La pagination permet de charger les données par lots pour optimiser les performances et l'expérience utilisateur. Il existe plusieurs approches selon le cas d'usage.

**Types de pagination :**

- **Offset-based** : pagination classique par numéro de page
- **Cursor-based** : pagination par curseur (meilleure pour les données en temps réel)
- **Infinite scroll** : chargement infini au scroll
- **Load more** : bouton "Voir plus"

## Exemple de mise en pratique

**Pagination offset-based (classique) :**

```ts
// src/features/products/types.ts
import { z } from "zod";

export const paginationParamsSchema = z.object({
  page: z.number().int().positive().default(1),
  limit: z.number().int().positive().max(100).default(20),
});

export type PaginationParams = z.infer<typeof paginationParamsSchema>;

export type PaginatedResponse<T> = {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasMore: boolean;
  };
};
```

**Service API avec pagination :**

```ts
// src/features/products/services/products-api.ts
import { apiClient } from "@/lib/axios";
import type { Product, PaginationParams, PaginatedResponse } from "../types";

export async function fetchProducts(params: PaginationParams): Promise<PaginatedResponse<Product>> {
  const { data } = await apiClient.get<PaginatedResponse<Product>>("/products", {
    params,
  });
  return data;
}
```

**Hook avec pagination :**

```ts
// src/features/products/hooks/use-products.ts
import { useQuery } from "@tanstack/react-query";
import { fetchProducts } from "../services";
import type { PaginationParams } from "../types";

export function useProducts(params: PaginationParams) {
  return useQuery({
    queryKey: ["products", params],
    queryFn: () => fetchProducts(params),
    placeholderData: (previousData) => previousData, // Garder les données précédentes pendant le chargement
  });
}
```

**Composant avec pagination :**

```tsx
// src/features/products/components/product-list.tsx
import { useState } from "react";
import { useProducts } from "../hooks";

export function ProductList() {
  const [page, setPage] = useState(1);
  const { data, isLoading, isPlaceholderData } = useProducts({ page, limit: 20 });

  if (isLoading && !data) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <div className={isPlaceholderData ? "opacity-50" : ""}>
        {data?.data.map((product) => (
          <ProductCard key={product.id} product={product} />
        ))}
      </div>

      <div className="pagination">
        <button onClick={() => setPage((p) => Math.max(1, p - 1))} disabled={page === 1 || isPlaceholderData}>
          Previous
        </button>

        <span>
          Page {data?.pagination.page} of {data?.pagination.totalPages}
        </span>

        <button
          onClick={() => setPage((p) => p + 1)}
          disabled={!data?.pagination.hasMore || isPlaceholderData}
        >
          Next
        </button>
      </div>
    </div>
  );
}
```

**Pagination avec numéros de pages :**

```tsx
// src/features/products/components/paginated-product-list.tsx
import { useState } from "react";
import { useProducts } from "../hooks";

export function PaginatedProductList() {
  const [page, setPage] = useState(1);
  const { data, isLoading } = useProducts({ page, limit: 20 });

  const totalPages = data?.pagination.totalPages || 1;

  // Générer les numéros de pages à afficher
  const getPageNumbers = () => {
    const delta = 2;
    const range = [];
    const rangeWithDots = [];

    for (let i = Math.max(2, page - delta); i <= Math.min(totalPages - 1, page + delta); i++) {
      range.push(i);
    }

    if (page - delta > 2) {
      rangeWithDots.push(1, "...");
    } else {
      rangeWithDots.push(1);
    }

    rangeWithDots.push(...range);

    if (page + delta < totalPages - 1) {
      rangeWithDots.push("...", totalPages);
    } else if (totalPages > 1) {
      rangeWithDots.push(totalPages);
    }

    return rangeWithDots;
  };

  if (isLoading) return <div>Loading...</div>;

  return (
    <div>
      <div>
        {data?.data.map((product) => (
          <ProductCard key={product.id} product={product} />
        ))}
      </div>

      <div className="flex gap-2">
        {getPageNumbers().map((pageNum, idx) =>
          pageNum === "..." ? (
            <span key={`dots-${idx}`}>...</span>
          ) : (
            <button
              key={pageNum}
              onClick={() => setPage(Number(pageNum))}
              className={page === pageNum ? "font-bold" : ""}
            >
              {pageNum}
            </button>
          )
        )}
      </div>
    </div>
  );
}
```

**Infinite Query (scroll infini) :**

```ts
// src/features/posts/hooks/use-infinite-posts.ts
import { useInfiniteQuery } from "@tanstack/react-query";
import { fetchPosts } from "../services";

export function useInfinitePosts() {
  return useInfiniteQuery({
    queryKey: ["posts", "infinite"],
    queryFn: ({ pageParam = 1 }) => fetchPosts({ page: pageParam, limit: 20 }),
    getNextPageParam: (lastPage) => {
      return lastPage.pagination.hasMore ? lastPage.pagination.page + 1 : undefined;
    },
    initialPageParam: 1,
  });
}
```

**Composant avec infinite scroll :**

```tsx
// src/features/posts/components/infinite-post-list.tsx
import { useEffect, useRef } from "react";
import { useInfinitePosts } from "../hooks";

export function InfinitePostList() {
  const { data, fetchNextPage, hasNextPage, isFetchingNextPage, isLoading } = useInfinitePosts();

  const loadMoreRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!loadMoreRef.current) return;

    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasNextPage && !isFetchingNextPage) {
          fetchNextPage();
        }
      },
      { threshold: 1.0 }
    );

    observer.observe(loadMoreRef.current);

    return () => observer.disconnect();
  }, [fetchNextPage, hasNextPage, isFetchingNextPage]);

  if (isLoading) return <div>Loading...</div>;

  return (
    <div>
      {data?.pages.map((page) =>
        page.data.map((post) => <PostCard key={post.id} post={post} />)
      )}

      <div ref={loadMoreRef} className="h-10 flex items-center justify-center">
        {isFetchingNextPage && <span>Loading more...</span>}
      </div>
    </div>
  );
}
```

**Bouton "Load More" :**

```tsx
// src/features/posts/components/load-more-post-list.tsx
import { useInfinitePosts } from "../hooks";

export function LoadMorePostList() {
  const { data, fetchNextPage, hasNextPage, isFetchingNextPage, isLoading } = useInfinitePosts();

  if (isLoading) return <div>Loading...</div>;

  return (
    <div>
      {data?.pages.map((page) =>
        page.data.map((post) => <PostCard key={post.id} post={post} />)
      )}

      {hasNextPage && (
        <button onClick={() => fetchNextPage()} disabled={isFetchingNextPage}>
          {isFetchingNextPage ? "Loading..." : "Load More"}
        </button>
      )}
    </div>
  );
}
```

**Pagination cursor-based :**

```ts
// src/features/messages/types.ts
export type CursorPaginationParams = {
  cursor?: string;
  limit?: number;
};

export type CursorPaginatedResponse<T> = {
  data: T[];
  nextCursor: string | null;
  hasMore: boolean;
};
```

**Service avec cursor :**

```ts
// src/features/messages/services/messages-api.ts
import { apiClient } from "@/lib/axios";
import type { Message, CursorPaginationParams, CursorPaginatedResponse } from "../types";

export async function fetchMessages(
  params: CursorPaginationParams
): Promise<CursorPaginatedResponse<Message>> {
  const { data } = await apiClient.get<CursorPaginatedResponse<Message>>("/messages", {
    params,
  });
  return data;
}
```

**Hook avec cursor pagination :**

```ts
// src/features/messages/hooks/use-infinite-messages.ts
import { useInfiniteQuery } from "@tanstack/react-query";
import { fetchMessages } from "../services";

export function useInfiniteMessages() {
  return useInfiniteQuery({
    queryKey: ["messages", "infinite"],
    queryFn: ({ pageParam }) => fetchMessages({ cursor: pageParam, limit: 50 }),
    getNextPageParam: (lastPage) => lastPage.nextCursor,
    initialPageParam: undefined,
  });
}
```

**Pagination avec filtres :**

```tsx
// src/features/products/components/filtered-product-list.tsx
import { useState } from "react";
import { useProducts } from "../hooks";

export function FilteredProductList() {
  const [page, setPage] = useState(1);
  const [category, setCategory] = useState<string | undefined>();
  const [search, setSearch] = useState("");

  const { data, isLoading } = useProducts({
    page,
    limit: 20,
    category,
    search: search || undefined,
  });

  // Reset la page quand les filtres changent
  const handleCategoryChange = (newCategory: string) => {
    setCategory(newCategory);
    setPage(1);
  };

  const handleSearch = (value: string) => {
    setSearch(value);
    setPage(1);
  };

  return (
    <div>
      <div className="filters">
        <input
          type="text"
          placeholder="Search..."
          value={search}
          onChange={(e) => handleSearch(e.target.value)}
        />
        <select value={category} onChange={(e) => handleCategoryChange(e.target.value)}>
          <option value="">All categories</option>
          <option value="electronics">Electronics</option>
          <option value="clothing">Clothing</option>
        </select>
      </div>

      {isLoading ? (
        <div>Loading...</div>
      ) : (
        <>
          <div>
            {data?.data.map((product) => (
              <ProductCard key={product.id} product={product} />
            ))}
          </div>

          <Pagination
            currentPage={page}
            totalPages={data?.pagination.totalPages || 1}
            onPageChange={setPage}
          />
        </>
      )}
    </div>
  );
}
```

**Pagination avec URL search params :**

```tsx
// src/features/products/components/product-list-with-url.tsx
import { useSearchParams } from "next/navigation";
import { useProducts } from "../hooks";

export function ProductListWithUrl() {
  const searchParams = useSearchParams();
  const page = Number(searchParams.get("page")) || 1;

  const { data, isLoading } = useProducts({ page, limit: 20 });

  const updatePage = (newPage: number) => {
    const params = new URLSearchParams(searchParams);
    params.set("page", String(newPage));
    window.history.pushState(null, "", `?${params.toString()}`);
  };

  if (isLoading) return <div>Loading...</div>;

  return (
    <div>
      <div>
        {data?.data.map((product) => (
          <ProductCard key={product.id} product={product} />
        ))}
      </div>

      <div>
        <button onClick={() => updatePage(page - 1)} disabled={page === 1}>
          Previous
        </button>
        <span>Page {page}</span>
        <button onClick={() => updatePage(page + 1)} disabled={!data?.pagination.hasMore}>
          Next
        </button>
      </div>
    </div>
  );
}
```

**Composant Pagination réutilisable :**

```tsx
// src/ui/components/pagination.tsx
interface PaginationProps {
  currentPage: number;
  totalPages: number;
  onPageChange: (page: number) => void;
  disabled?: boolean;
}

export function Pagination({ currentPage, totalPages, onPageChange, disabled }: PaginationProps) {
  const canGoPrevious = currentPage > 1;
  const canGoNext = currentPage < totalPages;

  return (
    <div className="flex items-center gap-2">
      <button
        onClick={() => onPageChange(1)}
        disabled={!canGoPrevious || disabled}
        className="px-3 py-1 border rounded"
      >
        First
      </button>

      <button
        onClick={() => onPageChange(currentPage - 1)}
        disabled={!canGoPrevious || disabled}
        className="px-3 py-1 border rounded"
      >
        Previous
      </button>

      <span className="px-3 py-1">
        Page {currentPage} of {totalPages}
      </span>

      <button
        onClick={() => onPageChange(currentPage + 1)}
        disabled={!canGoNext || disabled}
        className="px-3 py-1 border rounded"
      >
        Next
      </button>

      <button
        onClick={() => onPageChange(totalPages)}
        disabled={!canGoNext || disabled}
        className="px-3 py-1 border rounded"
      >
        Last
      </button>
    </div>
  );
}
```

**API Route avec pagination :**

```ts
// app/api/products/route.ts
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { paginationParamsSchema } from "@/features/products/types";

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const page = Number(searchParams.get("page")) || 1;
  const limit = Number(searchParams.get("limit")) || 20;

  // Valider les paramètres
  const params = paginationParamsSchema.parse({ page, limit });

  // Calculer l'offset
  const skip = (params.page - 1) * params.limit;

  // Récupérer les données et le total
  const [products, total] = await Promise.all([
    prisma.product.findMany({
      skip,
      take: params.limit,
      orderBy: { createdAt: "desc" },
    }),
    prisma.product.count(),
  ]);

  const totalPages = Math.ceil(total / params.limit);

  return NextResponse.json({
    data: products,
    pagination: {
      page: params.page,
      limit: params.limit,
      total,
      totalPages,
      hasMore: params.page < totalPages,
    },
  });
}
```

**Prefetch pour navigation optimale :**

```tsx
// src/features/products/components/product-list-with-prefetch.tsx
import { useState } from "react";
import { useQueryClient } from "@tanstack/react-query";
import { useProducts } from "../hooks";
import { fetchProducts } from "../services";

export function ProductListWithPrefetch() {
  const [page, setPage] = useState(1);
  const queryClient = useQueryClient();
  const { data, isLoading } = useProducts({ page, limit: 20 });

  const prefetchNext = () => {
    if (data?.pagination.hasMore) {
      queryClient.prefetchQuery({
        queryKey: ["products", { page: page + 1, limit: 20 }],
        queryFn: () => fetchProducts({ page: page + 1, limit: 20 }),
      });
    }
  };

  const prefetchPrevious = () => {
    if (page > 1) {
      queryClient.prefetchQuery({
        queryKey: ["products", { page: page - 1, limit: 20 }],
        queryFn: () => fetchProducts({ page: page - 1, limit: 20 }),
      });
    }
  };

  if (isLoading) return <div>Loading...</div>;

  return (
    <div>
      <div>
        {data?.data.map((product) => (
          <ProductCard key={product.id} product={product} />
        ))}
      </div>

      <div>
        <button
          onClick={() => setPage((p) => p - 1)}
          onMouseEnter={prefetchPrevious}
          disabled={page === 1}
        >
          Previous
        </button>

        <button
          onClick={() => setPage((p) => p + 1)}
          onMouseEnter={prefetchNext}
          disabled={!data?.pagination.hasMore}
        >
          Next
        </button>
      </div>
    </div>
  );
}
```

## Variantes ou exceptions

- Les petites listes (< 100 items) peuvent ne pas nécessiter de pagination.
- Les données en temps réel utilisent souvent cursor-based pagination.

## Liens / Références

- [TanStack Query Pagination](https://tanstack.com/query/latest/docs/react/guides/paginated-queries)
- [TanStack Query Infinite Queries](https://tanstack.com/query/latest/docs/react/guides/infinite-queries)
- Documentation interne : `references.md`
