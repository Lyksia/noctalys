---
alwaysApply: false
description: Frame mutations and revalidations
---

# Mutations et revalidations

**Objectif** : Encadrer les mutations (create, update, delete) et les revalidations de cache avec React Query.

**Contexte** : À appliquer pour garantir la cohérence de la gestion de l'état et des données.

## Explication

Les mutations modifient les données sur le serveur. Après une mutation réussie, il faut invalider ou mettre à jour le cache pour refléter les changements.

**Principes clés :**

- **useMutation pour toutes les modifications**
- **Invalidation automatique du cache**
- **Gestion d'erreurs cohérente**
- **Feedback utilisateur (loading, success, error)**
- **Optimistic updates quand approprié**

## Exemple de mise en pratique

**Mutation simple :**

```ts
// src/features/users/hooks/use-create-user.ts
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { createUser } from "../services";
import { userKeys } from "../queries";
import type { CreateUserInput } from "../types";

export function useCreateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreateUserInput) => createUser(data),
    onSuccess: () => {
      // Invalider toutes les queries de users
      queryClient.invalidateQueries({ queryKey: userKeys.all });
    },
  });
}

// Usage dans un composant
export function CreateUserForm() {
  const createMutation = useCreateUser();

  const handleSubmit = async (data: CreateUserInput) => {
    try {
      await createMutation.mutateAsync(data);
      toast.success("User created successfully");
      router.push("/users");
    } catch (error) {
      toast.error("Failed to create user");
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Form fields */}
      <button type="submit" disabled={createMutation.isPending}>
        {createMutation.isPending ? "Creating..." : "Create User"}
      </button>
      {createMutation.error && <div className="text-red-500">{createMutation.error.message}</div>}
    </form>
  );
}
```

**Mutation avec mise à jour du cache :**

```ts
// src/features/users/hooks/use-update-user.ts
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { updateUser } from "../services";
import { userKeys } from "../queries";
import type { User, UpdateUserInput } from "../types";

export function useUpdateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateUserInput }) => updateUser(id, data),
    onSuccess: (updatedUser) => {
      // Mettre à jour directement le cache
      queryClient.setQueryData<User>(userKeys.detail(updatedUser.id), updatedUser);

      // Invalider la liste pour refetch
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    },
  });
}
```

**Mutation avec optimistic update :**

```ts
// src/features/todos/hooks/use-toggle-todo.ts
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { toggleTodo } from "../services";
import { todoKeys } from "../queries";
import type { Todo } from "../types";

export function useToggleTodo() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (todoId: string) => toggleTodo(todoId),
    // Optimistic update avant l'appel API
    onMutate: async (todoId) => {
      // Annuler les refetch en cours
      await queryClient.cancelQueries({ queryKey: todoKeys.all });

      // Snapshot des données actuelles
      const previousTodos = queryClient.getQueryData<Todo[]>(todoKeys.all);

      // Mise à jour optimiste
      queryClient.setQueryData<Todo[]>(todoKeys.all, (old) => {
        if (!old) return [];
        return old.map((todo) => (todo.id === todoId ? { ...todo, completed: !todo.completed } : todo));
      });

      // Retourner le contexte pour rollback
      return { previousTodos };
    },
    // Rollback en cas d'erreur
    onError: (err, todoId, context) => {
      if (context?.previousTodos) {
        queryClient.setQueryData(todoKeys.all, context.previousTodos);
      }
      toast.error("Failed to update todo");
    },
    // Refetch après succès ou erreur
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: todoKeys.all });
    },
  });
}
```

**Mutation avec invalidation sélective :**

```ts
// src/features/posts/hooks/use-delete-post.ts
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { deletePost } from "../services";
import { postKeys } from "../queries";

export function useDeletePost() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (postId: string) => deletePost(postId),
    onSuccess: (_, postId) => {
      // Retirer du cache directement
      queryClient.removeQueries({ queryKey: postKeys.detail(postId) });

      // Invalider les listes
      queryClient.invalidateQueries({ queryKey: postKeys.lists() });

      // Invalider les posts de l'auteur
      queryClient.invalidateQueries({ queryKey: ["users", "*", "posts"] });
    },
  });
}
```

**Mutation en série :**

```ts
// src/features/orders/hooks/use-create-order.ts
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { createOrder, processPayment, sendConfirmation } from "../services";
import type { CreateOrderInput } from "../types";

export function useCreateOrder() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: CreateOrderInput) => {
      // 1. Créer la commande
      const order = await createOrder(data);

      // 2. Traiter le paiement
      const payment = await processPayment(order.id, data.paymentMethod);

      // 3. Envoyer la confirmation
      await sendConfirmation(order.id);

      return { order, payment };
    },
    onSuccess: ({ order }) => {
      queryClient.invalidateQueries({ queryKey: ["orders"] });
      queryClient.invalidateQueries({ queryKey: ["cart"] });
      toast.success(`Order ${order.id} created successfully`);
    },
    onError: (error) => {
      toast.error("Failed to create order");
      // Log pour debugging
      console.error("Order creation failed:", error);
    },
  });
}
```

**Mutations multiples en parallèle :**

```ts
// src/features/bulk/hooks/use-bulk-delete.ts
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { deleteUser } from "../services";
import { userKeys } from "../queries";

export function useBulkDeleteUsers() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (userIds: string[]) => {
      // Supprimer tous les utilisateurs en parallèle
      await Promise.all(userIds.map((id) => deleteUser(id)));
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: userKeys.all });
      toast.success("Users deleted successfully");
    },
  });
}
```

**Mutation avec retry :**

```ts
// src/features/uploads/hooks/use-upload-file.ts
import { useMutation } from "@tanstack/react-query";
import { uploadFile } from "../services";

export function useUploadFile() {
  return useMutation({
    mutationFn: (file: File) => uploadFile(file),
    retry: 2, // Retry 2 fois en cas d'échec
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 10000),
    onError: (error) => {
      toast.error("Failed to upload file after multiple attempts");
    },
  });
}
```

**Mutation avec progress :**

```tsx
// src/features/uploads/components/file-upload.tsx
import { useMutation } from "@tanstack/react-query";
import { useState } from "react";
import { uploadFile } from "../services";

export function FileUpload() {
  const [progress, setProgress] = useState(0);

  const uploadMutation = useMutation({
    mutationFn: (file: File) => uploadFile(file, setProgress),
    onSuccess: () => {
      toast.success("File uploaded successfully");
      setProgress(0);
    },
  });

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      uploadMutation.mutate(file);
    }
  };

  return (
    <div>
      <input type="file" onChange={handleFileChange} disabled={uploadMutation.isPending} />
      {uploadMutation.isPending && (
        <div>
          <progress value={progress} max={100} />
          <span>{progress}%</span>
        </div>
      )}
    </div>
  );
}
```

**Mutation avec confirmation :**

```tsx
// src/features/users/components/delete-user-button.tsx
import { useDeleteUser } from "../hooks";

export function DeleteUserButton({ userId }: { userId: string }) {
  const deleteMutation = useDeleteUser();

  const handleDelete = async () => {
    if (!confirm("Are you sure you want to delete this user?")) {
      return;
    }

    try {
      await deleteMutation.mutateAsync(userId);
      toast.success("User deleted");
    } catch (error) {
      toast.error("Failed to delete user");
    }
  };

  return (
    <button onClick={handleDelete} disabled={deleteMutation.isPending}>
      {deleteMutation.isPending ? "Deleting..." : "Delete"}
    </button>
  );
}
```

**Mutation avec invalidation globale :**

```ts
// src/features/auth/hooks/use-logout.ts
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { logout } from "../services";

export function useLogout() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: logout,
    onSuccess: () => {
      // Invalider TOUT le cache
      queryClient.clear();
      // Ou invalider sélectivement
      queryClient.removeQueries();

      router.push("/login");
    },
  });
}
```

**Mutation avec callback :**

```ts
// src/features/users/hooks/use-create-user.ts
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { createUser } from "../services";
import type { CreateUserInput } from "../types";

interface UseCreateUserOptions {
  onSuccess?: (userId: string) => void;
  onError?: (error: Error) => void;
}

export function useCreateUser(options: UseCreateUserOptions = {}) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreateUserInput) => createUser(data),
    onSuccess: (user) => {
      queryClient.invalidateQueries({ queryKey: ["users"] });
      options.onSuccess?.(user.id);
    },
    onError: (error) => {
      options.onError?.(error);
    },
  });
}

// Usage avec callback custom
const createMutation = useCreateUser({
  onSuccess: (userId) => {
    console.log("User created:", userId);
    router.push(`/users/${userId}`);
  },
});
```

## Variantes ou exceptions

- Les optimistic updates ne sont pas recommandés pour les opérations critiques (paiements).
- Les mutations très complexes peuvent nécessiter un état local supplémentaire.

## Liens / Références

- [TanStack Query Mutations](https://tanstack.com/query/latest/docs/react/guides/mutations)
- [Optimistic Updates](https://tanstack.com/query/latest/docs/react/guides/optimistic-updates)
- Documentation interne : `references.md`
