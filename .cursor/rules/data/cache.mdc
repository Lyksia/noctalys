---
alwaysApply: false
description: Define cache strategies and invalidation
---

# Cache Strategies

**Objective**: Define cache and invalidation strategies to optimize performance and ensure data freshness.

**Context**: To apply for ensuring consistency in state and data management.

## Explanation

Caching reduces API calls and improves performance. React Query handles caching automatically, but strategies must be configured according to needs.

**Key concepts:**

- **staleTime**: time before data is considered stale
- **gcTime**: time before data is removed from cache (formerly cacheTime)
- **Invalidation**: force data refetching
- **Prefetch**: load data in advance

## Practical Implementation Example

**Global cache configuration:**

```ts
// src/lib/react-query.ts
import { QueryClient } from "@tanstack/react-query";

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes - data considered fresh for 5 min
      gcTime: 10 * 60 * 1000, // 10 minutes - data kept in cache for 10 min
      refetchOnWindowFocus: false, // Don't refetch on window focus
      refetchOnReconnect: true, // Refetch on reconnection
      retry: 1, // Retry once on error
    },
  },
});
```

**Strategy by data type:**

```ts
// src/features/users/hooks/use-users.ts
import { useQuery } from "@tanstack/react-query";
import { fetchUsers } from "../services";

// Low volatility data (users)
export function useUsers() {
  return useQuery({
    queryKey: ["users"],
    queryFn: fetchUsers,
    staleTime: 10 * 60 * 1000, // 10 minutes
    gcTime: 30 * 60 * 1000, // 30 minutes
  });
}

// Volatile data (notifications)
export function useNotifications() {
  return useQuery({
    queryKey: ["notifications"],
    queryFn: fetchNotifications,
    staleTime: 30 * 1000, // 30 seconds
    gcTime: 2 * 60 * 1000, // 2 minutes
    refetchInterval: 30000, // Polling every 30 seconds
  });
}

// Static data (configuration)
export function useConfig() {
  return useQuery({
    queryKey: ["config"],
    queryFn: fetchConfig,
    staleTime: Infinity, // Never stale
    gcTime: Infinity, // Always in cache
  });
}
```

**Invalidation after mutation:**

```ts
// src/features/users/hooks/use-create-user.ts
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { createUser } from "../services";
import { userKeys } from "../queries";

export function useCreateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: createUser,
    onSuccess: () => {
      // Invalidate all users queries
      queryClient.invalidateQueries({ queryKey: userKeys.all });

      // Or invalidate selectively
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    },
  });
}
```

**Selective invalidation:**

```ts
// src/features/posts/hooks/use-update-post.ts
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { updatePost } from "../services";

export function useUpdatePost() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ postId, data }: { postId: string; data: UpdatePostInput }) => updatePost(postId, data),
    onSuccess: (updatedPost) => {
      // Update specific post cache
      queryClient.setQueryData(["posts", updatedPost.id], updatedPost);

      // Invalidate lists (without invalidating details)
      queryClient.invalidateQueries({
        queryKey: ["posts"],
        refetchType: "none", // Don't refetch immediately
      });

      // Invalidate only lists, not details
      queryClient.invalidateQueries({
        queryKey: ["posts", "list"],
      });
    },
  });
}
```

**Prefetch for optimal navigation:**

```tsx
// src/features/products/components/product-list.tsx
import { useQueryClient } from "@tanstack/react-query";
import { useQuery } from "@tanstack/react-query";
import { fetchProducts, fetchProductById } from "../services";
import Link from "next/link";

export function ProductList() {
  const queryClient = useQueryClient();
  const { data: products } = useQuery({
    queryKey: ["products"],
    queryFn: fetchProducts,
  });

  const handleMouseEnter = (productId: string) => {
    // Prefetch on hover for instant navigation
    queryClient.prefetchQuery({
      queryKey: ["products", productId],
      queryFn: () => fetchProductById(productId),
      staleTime: 5 * 60 * 1000,
    });
  };

  return (
    <div>
      {products?.map((product) => (
        <Link
          key={product.id}
          href={`/products/${product.id}`}
          onMouseEnter={() => handleMouseEnter(product.id)}
        >
          {product.name}
        </Link>
      ))}
    </div>
  );
}
```

**Manual cache update:**

```ts
// src/features/users/hooks/use-update-user.ts
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { updateUser } from "../services";
import type { User } from "../types";

export function useUpdateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: Partial<User> }) => updateUser(id, data),
    onSuccess: (updatedUser) => {
      // Update cache directly
      queryClient.setQueryData<User>(["users", updatedUser.id], updatedUser);

      // Update in list as well
      queryClient.setQueryData<User[]>(["users"], (old) => {
        if (!old) return [];
        return old.map((user) => (user.id === updatedUser.id ? updatedUser : user));
      });
    },
  });
}
```

**Cache with dependencies:**

```ts
// src/features/posts/hooks/use-post-with-comments.ts
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { fetchPost, fetchComments } from "../services";

export function usePostWithComments(postId: string) {
  const queryClient = useQueryClient();

  // Query 1: Post
  const postQuery = useQuery({
    queryKey: ["posts", postId],
    queryFn: () => fetchPost(postId),
    staleTime: 5 * 60 * 1000,
  });

  // Query 2: Comments (depends on post)
  const commentsQuery = useQuery({
    queryKey: ["posts", postId, "comments"],
    queryFn: () => fetchComments(postId),
    enabled: !!postQuery.data, // Wait for post to load
    staleTime: 2 * 60 * 1000, // Shorter because more volatile
  });

  return {
    post: postQuery.data,
    comments: commentsQuery.data,
    isLoading: postQuery.isLoading || commentsQuery.isLoading,
  };
}
```

**Manual cache removal:**

```ts
// src/features/users/hooks/use-delete-user.ts
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { deleteUser } from "../services";

export function useDeleteUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (userId: string) => deleteUser(userId),
    onSuccess: (_, userId) => {
      // Remove from cache
      queryClient.removeQueries({ queryKey: ["users", userId] });

      // Update list
      queryClient.setQueryData<User[]>(["users"], (old) => {
        if (!old) return [];
        return old.filter((user) => user.id !== userId);
      });
    },
  });
}
```

**Complete cache reset:**

```ts
// src/features/auth/hooks/use-logout.ts
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { logout } from "../services";

export function useLogout() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: logout,
    onSuccess: () => {
      // Clear entire cache
      queryClient.clear();

      // Or keep certain queries (config, etc.)
      queryClient.removeQueries({
        predicate: (query) => {
          return !query.queryKey.includes("config");
        },
      });

      router.push("/login");
    },
  });
}
```

**Cache with placeholderData:**

```ts
// src/features/products/hooks/use-products.ts
import { useQuery } from "@tanstack/react-query";
import { fetchProducts } from "../services";

export function useProducts(page: number) {
  return useQuery({
    queryKey: ["products", page],
    queryFn: () => fetchProducts({ page }),
    // Keep previous data during loading
    placeholderData: (previousData) => previousData,
  });
}

// UI doesn't flicker between pages
```

**Revalidation on focus:**

```ts
// src/features/dashboard/hooks/use-stats.ts
import { useQuery } from "@tanstack/react-query";
import { fetchStats } from "../services";

export function useStats() {
  return useQuery({
    queryKey: ["stats"],
    queryFn: fetchStats,
    staleTime: 2 * 60 * 1000, // 2 minutes
    refetchOnWindowFocus: true, // Refetch when user returns to tab
    refetchInterval: 60000, // Refetch every 60 seconds if active
  });
}
```

**Cache strategy by environment:**

```ts
// src/lib/react-query.ts
import { QueryClient } from "@tanstack/react-query";

const isDev = process.env.NODE_ENV === "development";

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: isDev ? 0 : 5 * 60 * 1000, // No cache in dev
      gcTime: isDev ? 0 : 10 * 60 * 1000,
      refetchOnWindowFocus: !isDev,
      retry: isDev ? 0 : 1, // No retry in dev
    },
  },
});
```

## Variants or Exceptions

- Sensitive data should not be cached for too long.
- Real-time applications may require very short staleTime.

## Links / References

- [TanStack Query Caching](https://tanstack.com/query/latest/docs/react/guides/caching)
- [Important Defaults](https://tanstack.com/query/latest/docs/react/guides/important-defaults)
- Internal documentation: `references.md`
