---
id: deployment/cache
category: deployment
title: Cache
status: draft
tags: [cache, optimization, performance, vercel, nextjs]
---

# Cache

**Objectif** : Gérer le cache et les optimisations de performance sur Vercel pour améliorer les temps de chargement.
**Contexte** : À appliquer pour les étapes de déploiement et intégration continue.

## Explication

Next.js et Vercel offrent plusieurs niveaux de cache pour optimiser les performances :

| Type de cache         | Durée                | Contrôle                    | Usage                          |
| --------------------- | -------------------- | --------------------------- | ------------------------------ |
| Build cache           | Persistant           | Automatique (Vercel)        | Accélère les builds            |
| Static pages          | Jusqu'au redéploiement | `revalidate` ou ISR        | Pages statiques (SSG)          |
| API responses         | Configurable         | Headers `Cache-Control`     | Réponses API                   |
| Images                | 31 jours (max)       | Next.js Image Optimization  | Images optimisées              |
| Assets statiques      | 31 jours             | Automatique                 | CSS, JS, fonts                 |
| Edge cache            | Configurable         | Vercel Edge Network         | CDN global                     |

**Principes clés :**
- Utiliser ISR (Incremental Static Regeneration) pour les contenus semi-dynamiques.
- Configurer les headers `Cache-Control` pour les API routes.
- Optimiser les images avec `next/image`.
- Purger le cache lors des déploiements si nécessaire.

## Exemple de mise en pratique

**Pages statiques avec revalidation (ISR) :**

```tsx
// app/blog/[slug]/page.tsx
export const revalidate = 3600; // Revalide toutes les heures

export default async function BlogPost({ params }: { params: { slug: string } }) {
  const post = await fetchPost(params.slug);
  
  return (
    <article>
      <h1>{post.title}</h1>
      <div>{post.content}</div>
    </article>
  );
}
```

**API routes avec Cache-Control :**

```ts
// app/api/posts/route.ts
export async function GET() {
  const posts = await fetchPosts();
  
  return Response.json(posts, {
    headers: {
      'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=86400',
    },
  });
}
```

**Optimisation des images :**

```tsx
import Image from 'next/image';

export function Avatar({ src, alt }: { src: string; alt: string }) {
  return (
    <Image
      src={src}
      alt={alt}
      width={48}
      height={48}
      quality={85}
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,..."
    />
  );
}
```

**Configuration Next.js (next.config.js) :**

```js
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    domains: ['cdn.example.com'],
    formats: ['image/avif', 'image/webp'],
    minimumCacheTTL: 60 * 60 * 24 * 30, // 30 jours
  },
  
  // Cache automatique des fetches
  experimental: {
    staleTimes: {
      dynamic: 30, // 30 secondes pour les pages dynamiques
      static: 180, // 3 minutes pour les pages statiques
    },
  },
};

module.exports = nextConfig;
```

**Stratégies de revalidation :**

```tsx
// Revalidation au temps (ISR)
export const revalidate = 3600; // 1 heure

// Revalidation à la demande (via API)
// app/api/revalidate/route.ts
import { revalidatePath } from 'next/cache';

export async function POST(request: Request) {
  const { path } = await request.json();
  
  revalidatePath(path);
  
  return Response.json({ revalidated: true });
}
```

**Purge du cache Vercel via API :**

```ts
async function purgeCache(urls: string[]) {
  const response = await fetch(
    `https://api.vercel.com/v1/purge`,
    {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${process.env.VERCEL_TOKEN}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ urls }),
    }
  );
  
  return response.json();
}
```

**Configuration des headers (vercel.json) :**

```json
{
  "headers": [
    {
      "source": "/api/(.*)",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, s-maxage=3600, stale-while-revalidate=86400"
        }
      ]
    },
    {
      "source": "/(.*).jpg",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    }
  ]
}
```

## Variantes ou exceptions

- **No-cache pour les données sensibles** :
  ```ts
  headers: {
    'Cache-Control': 'no-store, no-cache, must-revalidate',
  }
  ```

- **Cache par utilisateur** : Utiliser des cookies/tokens pour personnaliser le cache.

- **Cache Redis** : Ajouter un cache applicatif avec Redis pour les données complexes.

- **Prefetching** : Next.js précharge automatiquement les liens visibles.

- **Service Worker** : Implémenter un SW custom pour du cache offline.

## Liens / Références

- [Next.js Caching](https://nextjs.org/docs/app/building-your-application/caching)
- [Vercel Edge Caching](https://vercel.com/docs/concepts/edge-network/caching)
- [Next.js ISR](https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration)
- [HTTP Cache Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)
- Documentation interne : `.cursor/docs/references.md`
